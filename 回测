from datetime import timedelta
import pandas as pd
import numpy as np
import os
import warnings
import pandas as pd
import numpy as np
import os
import matplotlib

matplotlib.use('TkAgg')
import matplotlib.pyplot as plt

import matplotlib.dates as mdates
import warnings
from datetime import timedelta

# --- 辅助设置 ---
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False
# 忽略 openpyxl 相关的警告
warnings.filterwarnings("ignore", category=UserWarning, module="openpyxl")

# =========================================================================
# === SimplePortfolioBacktester 类定义 (与上一步一致) ===
# =========================================================================

class SimplePortfolioBacktester:
    # __init__ 签名已根据您的要求调整：
    # csi_data_file -> 中证500全收益
    # csi500_simple_data_file -> 中证500普通收益 (原 hs300_data_file 映射)
    def __init__(self, data_path, stock_data_file, csi_data_file, csi500_simple_data_file):
        self.data_path = data_path
        self.stock_data_file = stock_data_file

        self.csi500_tr_data_file = csi_data_file
        self.csi500_sr_data_file = csi500_simple_data_file

        self.price_data = None
        self.custom_matrix = None

        self.csi500_tr_returns = None
        self.csi500_sr_returns = None

        self.metrics_results = {}
        self.daily_holdings_history = []

        self.initial_capital = 300000000  # 初始资金10亿
        self.buy_fee = 0.0003  # 买入费率 0.03% (万3)
        self.sell_fee = 0.0013  # 卖出费率 0.13% (含印花税)

        self._load_all_data()

    def _load_all_data(self):
        """加载所有数据：股票价格、自定义组合矩阵、中证500全收益、中证500普通收益。"""

        # 1. 加载股票收盘价 (假设路径)
        try:
            # 假设您提供的路径 'C:\Users\cufet\Desktop\测试集\中证500成分股数据-快照2.xlsx' 中 Sheet1 是价格数据
            file_path = os.path.join(self.data_path, self.stock_data_file)
            df = pd.read_excel(file_path, sheet_name='Sheet1', header=0)
            df = df.iloc[1:].set_index(df.columns[0])
            df.index = pd.to_datetime(df.index)
            df.columns = df.columns.astype(str)
            # 使用 ffill 填充缺失值，确保所有交易日都有数据
            self.price_data = df.apply(pd.to_numeric, errors='coerce').ffill()
            print(f"股票价格数据形状: {self.price_data.shape}")
        except Exception as e:
            print(f"加载股票价格数据失败: {e}")
            self.price_data = pd.DataFrame()

        # 2. 加载自定义组合状态矩阵 (假设权重在 '优化权重结果.xlsx' 的 '优化权重' Sheet)
        try:
            # 假设权重文件在 data_path 中，或者单独指定
            weights_file_path = os.path.join(self.data_path, '优化权重结果.xlsx')
            df = pd.read_excel(weights_file_path, sheet_name='Sheet1', index_col=0)
            self.custom_matrix = df
            self.custom_matrix.index = self.custom_matrix.index.astype(str)
            self.custom_matrix.columns = pd.to_datetime(self.custom_matrix.columns)
            print(f"自定义权重矩阵形状: {self.custom_matrix.shape}")
        except Exception as e:
            print(f"加载自定义权重矩阵失败: {e}")
            self.custom_matrix = pd.DataFrame()

        # 3. 加载中证500全收益指数数据 (CSI500_TR)
        try:
            file_path = os.path.join(self.data_path, self.csi500_tr_data_file)
            df = pd.read_excel(file_path, header=0)
            df.rename(columns={df.columns[0]: 'Date', df.columns[1]: 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.csi500_tr_returns = df['Close'].pct_change().dropna()
            print(f"中证500全收益指数数据形状: {self.csi500_tr_returns.shape}")
        except Exception as e:
            print(f"加载中证500全收益指数数据失败: {e}")
            self.csi500_tr_returns = pd.Series()

        # 4. 加载中证500普通指数数据 (CSI500_SR)
        try:
            file_path = os.path.join(self.data_path, self.csi500_sr_data_file)
            df = pd.read_excel(file_path, header=0)
            df.rename(columns={df.columns[0]: 'Date', df.columns[1]: 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.csi500_sr_returns = df['Close'].pct_change().dropna()
            print(f"中证500普通指数数据形状: {self.csi500_sr_returns.shape}")
        except Exception as e:
            print(f"加载中证500普通指数数据失败: {e}")
            self.csi500_sr_returns = pd.Series()

    # (get_custom_weights_by_date 方法：获取权重矩阵中最近的权重列)
    def get_custom_weights_by_date(self, rebalance_date):
        if self.custom_matrix.empty:
            return {}

        rebalance_date = pd.to_datetime(rebalance_date)

        valid_cols = self.custom_matrix.columns[self.custom_matrix.columns <= rebalance_date]
        if valid_cols.empty:
            return {}

        target_col_date = valid_cols.max()

        weights_series = self.custom_matrix[target_col_date].dropna()
        new_weights = weights_series[weights_series > 1e-8].to_dict()

        if not new_weights:
            return {}

        available_stocks_weights = {
            s: w for s, w in new_weights.items()
            if s in self.price_data.columns
        }

        total_weight = sum(available_stocks_weights.values())
        if total_weight > 0:
            available_stocks_weights = {s: w / total_weight for s, w in available_stocks_weights.items()}

        return available_stocks_weights

    def run_backtest(self, start_date='2023-01-20', end_date='2025-09-30'):
        """执行回测并返回结果DataFrame，采用增量调仓逻辑，并计算两个中证500基准净值。"""

        if (self.price_data.empty or self.custom_matrix.empty or
                self.csi500_tr_returns.empty or self.csi500_sr_returns.empty):
            print("数据不完整，无法进行回测。")
            return None

        # --- 确定回测周期和调仓日 ---
        rebalance_dates = self.custom_matrix.columns.sort_values().tolist()
        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)

        all_trading_dates = self.price_data.index.intersection(self.csi500_tr_returns.index).intersection(
            self.csi500_sr_returns.index)
        all_trading_dates = all_trading_dates[
            (all_trading_dates >= start_dt) &
            (all_trading_dates <= end_dt)
            ]

        if all_trading_dates.empty:
            print("回测区间内无交易日数据。")
            return None

        first_trading_date = all_trading_dates[0]
        future_rebalance_dates = [d for d in rebalance_dates if d > first_trading_date and d <= end_dt]

        # --- 初始化 ---
        strategy_name = 'BL优化策略'
        current_shares = {}
        cash = self.initial_capital
        cumulative_returns = pd.Series(index=all_trading_dates, dtype=float)

        csi500_tr_value = self.initial_capital
        csi500_tr_values = pd.Series(index=all_trading_dates, dtype=float)

        csi500_sr_value = self.initial_capital
        csi500_sr_values = pd.Series(index=all_trading_dates, dtype=float)

        self.daily_holdings_history = []

        print(f"--- 回测开始，初始资金: {self.initial_capital / 10000:.0f} 万元 ---")

        # # ==========================================================
        # # --- 强制在第一个交易日进行初始化建仓 ---
        # # ==========================================================
        # initial_weights = self.get_custom_weights_by_date(first_trading_date)
        #
        # try:
        #     initial_prices = self.price_data.loc[first_trading_date].to_dict()
        #     can_initial_trade = True
        # except KeyError:
        #     print(
        #         f"警告：第一个交易日 {first_trading_date.strftime('%Y-%m-%d')} 价格数据缺失，初始建仓失败。策略空仓开始。")
        #     can_initial_trade = False
        #
        # initial_buy_fee = 0
        # if can_initial_trade and initial_weights:
        #     buy_value_total = 0
        #     new_shares_to_buy = {}
        #     current_portfolio_value = cash
        #     for stock, weight in initial_weights.items():
        #         price = initial_prices.get(stock, 0)
        #         if price > 0 and weight > 0:
        #             target_value = current_portfolio_value * weight
        #             target_shares = int((target_value / price) // 100) * 100
        #             if target_shares > 0:
        #                 cost = target_shares * price
        #                 new_shares_to_buy[stock] = (target_shares, cost)
        #                 buy_value_total += cost
        #     if buy_value_total > 0 and buy_value_total <= cash:
        #         for stock, (shares, cost) in new_shares_to_buy.items():
        #             fee = cost * self.buy_fee
        #             initial_buy_fee += fee
        #             current_shares[stock] = shares
        #         cash -= buy_value_total
        #         cash -= initial_buy_fee
        #         print(
        #             f"**初始建仓日** {first_trading_date.strftime('%Y-%m-%d')} - 股票数: {len(current_shares)}, 费用: {initial_buy_fee:.2f}, 剩余现金: {cash:.2f}")

        # 记录前一日的持仓（用作今日期初）
        prev_shares = current_shares.copy()

        for i, date in enumerate(all_trading_dates):

            # --- 记录期初持仓 (前一日的期末) ---
            initial_holdings_data = []
            if i > 0 or (i == 0 and len(current_shares) > 0):
                try:
                    open_prices = self.price_data.loc[date].to_dict()
                except KeyError:
                    open_prices = {}

                for stock, shares in prev_shares.items():
                    price = open_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0 and shares > 0:
                        initial_holdings_data.append({
                            '日期': date,
                            '股票代码': stock,
                            '持仓类型': '期初',
                            '持仓股数': shares,
                            '收盘价': price,
                            '持仓市值': shares * price
                        })

            # --- 现金利息 ---
            if i > 0:
                daily_interest_rate = 0.015 / 252
                cash += cash * daily_interest_rate

            # --- 步骤 1：处理 i=0 的初始净值记录 ---
            if i == 0:
                cumulative_returns.loc[date] = self.initial_capital
                csi500_tr_values.loc[date] = self.initial_capital
                csi500_sr_values.loc[date] = self.initial_capital

                # 记录期初数据
            self.daily_holdings_history.extend(initial_holdings_data)

            # --- 步骤 2：增量调仓逻辑 ---
            if date in future_rebalance_dates:
                sell_fee_total = 0
                buy_fee_total = 0

                try:
                    current_prices = self.price_data.loc[date].to_dict()
                except KeyError:
                    print(f"警告：调仓日 {date.strftime('%Y-%m-%d')} 价格数据缺失，跳过调仓。")
                    prev_shares = current_shares.copy()
                    continue

                new_weights = self.get_custom_weights_by_date(date)

                # ... 增量调仓计算逻辑 (与原代码保持一致) ...
                current_market_value = sum(current_shares.get(stock, 0) * current_prices.get(stock, 0)
                                           for stock in current_shares.keys())
                current_portfolio_value = current_market_value + cash
                target_market_value = current_portfolio_value if new_weights else 0
                target_shares = {}
                stock_list_all = set(current_shares.keys()) | set(new_weights.keys())
                stock_diff = {}
                for stock in stock_list_all:
                    weight = new_weights.get(stock, 0)
                    price = current_prices.get(stock, 0)
                    current_s = current_shares.get(stock, 0)
                    if price > 0:
                        target_val = target_market_value * weight
                        target_s = int((target_val / price) // 100) * 100
                        diff = target_s - current_s
                        stock_diff[stock] = diff
                        target_shares[stock] = target_s
                sell_value_total = 0
                for stock, diff in stock_diff.items():
                    if diff < 0:
                        shares_to_sell = abs(diff)
                        price = current_prices.get(stock)
                        value = shares_to_sell * price
                        fee = value * self.sell_fee
                        sell_fee_total += fee
                        sell_value_total += value
                        current_shares[stock] = target_shares[stock]
                cash += (sell_value_total - sell_fee_total)
                buy_value_pending = 0
                buy_list = {}
                for stock, diff in stock_diff.items():
                    if diff > 0:
                        shares_to_buy = diff
                        price = current_prices.get(stock)
                        cost = shares_to_buy * price
                        buy_value_pending += cost
                        buy_list[stock] = (shares_to_buy, cost)
                if buy_value_pending > 0 and buy_value_pending <= cash:
                    for stock, (shares, cost) in buy_list.items():
                        fee = cost * self.buy_fee
                        buy_fee_total += fee
                        current_shares[stock] = target_shares[stock]
                    cash -= buy_value_pending
                    cash -= buy_fee_total
                    print(
                        f"调仓日 {date.strftime('%Y-%m-%d')} - 卖出费: {sell_fee_total:.2f}, 买入费: {buy_fee_total:.2f}, 调仓股票数: {len(current_shares)}, 剩余现金: {cash:.2f}")
                elif buy_value_pending > cash:
                    print(
                        f"警告：调仓日 {date.strftime('%Y-%m-%d')} 购买现金不足 ({buy_value_pending:.2f} > {cash:.2f})，放弃本次买入。")
                    for stock, diff in stock_diff.items():
                        if diff < 0:
                            pass
                # -------------------------------------------------------------

            # --- 步骤 3：每日净值更新 ---
            yesterday = all_trading_dates[i - 1] if i > 0 else date
            stock_market_value = 0

            end_holdings_data = []

            if current_shares:
                portfolio_stocks = list(current_shares.keys())
                try:
                    today_prices = self.price_data.loc[date, portfolio_stocks].to_dict()
                except KeyError:
                    if i > 0:
                        portfolio_value = cumulative_returns.loc[yesterday]
                        cumulative_returns.loc[date] = portfolio_value
                        csi500_tr_values.loc[date] = csi500_tr_values.loc[yesterday]
                        csi500_sr_values.loc[date] = csi500_sr_values.loc[yesterday]

                        prev_shares = current_shares.copy()
                        continue
                    else:
                        portfolio_value = self.initial_capital

                for stock, shares in current_shares.items():
                    price = today_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0:
                        stock_market_value += shares * price

                        end_holdings_data.append({
                            '日期': date,
                            '股票代码': stock,
                            '持仓类型': '期末',
                            '持仓股数': shares,
                            '收盘价': price,
                            '持仓市值': shares * price
                        })

                if date in future_rebalance_dates:
                    new_weights = self.get_custom_weights_by_date(date)
                    end_holdings_data = [holding for holding in end_holdings_data
                                         if new_weights.get(holding['股票代码'], 0) > 0]

            portfolio_value = stock_market_value + cash

            # 基准净值更新
            daily_csi500_tr_return = self.csi500_tr_returns.get(date, 0.0)
            daily_csi500_sr_return = self.csi500_sr_returns.get(date, 0.0)

            if i > 0:
                csi500_tr_value *= (1 + daily_csi500_tr_return)
                csi500_sr_value *= (1 + daily_csi500_sr_return)

                # --- 步骤 4：记录净值 ---
            if i > 0 or (i == 0 and len(current_shares) > 0):
                cumulative_returns.loc[date] = portfolio_value
                csi500_tr_values.loc[date] = csi500_tr_value
                csi500_sr_values.loc[date] = csi500_sr_value

            self.daily_holdings_history.extend(end_holdings_data)
            prev_shares = current_shares.copy()

        # 将净值数据合并，并计算每日收益率
        cumulative_value_df = pd.DataFrame({
            strategy_name: cumulative_returns,
            'CSI500_TR_Benchmark_Value': csi500_tr_values,
            'CSI500_SR_Benchmark_Value': csi500_sr_values
        }).dropna()

        daily_returns_df = cumulative_value_df.pct_change().dropna()
        self.calculate_metrics(daily_returns_df, cumulative_value_df)

        # 季度收益率统计
        quarterly_value_df = cumulative_value_df.resample('Q').ffill().dropna()
        quarterly_returns_df = quarterly_value_df.pct_change().dropna()

        quarterly_returns_df.rename(columns={
            strategy_name: f'{strategy_name}_季度收益率(%)',
            'CSI500_TR_Benchmark_Value': 'CSI500_TR_Benchmark_季度收益率(%)',
            'CSI500_SR_Benchmark_Value': 'CSI500_SR_Benchmark_季度收益率(%)'
        }, inplace=True)

        quarterly_returns_df *= 100
        print("\n--- 季度收益率统计 ---")
        print(quarterly_returns_df)

        # 最终返回累计收益率百分比
        results_df = pd.DataFrame({
            strategy_name: (cumulative_returns / self.initial_capital - 1) * 100,
            'CSI500_TR_Benchmark': (csi500_tr_values / self.initial_capital - 1) * 100,
            'CSI500_SR_Benchmark': (csi500_sr_values / self.initial_capital - 1) * 100
        })

        return results_df.dropna()

    def _output_holdings_to_excel(self, output_file_name="个股持仓市值详情.xlsx"):
        """将收集到的每日持仓市值数据导出到 Excel，按调仓日分sheet，宽数据格式"""
        if not self.daily_holdings_history:
            print("持仓历史数据为空，不进行导出。")
            return

        df = pd.DataFrame(self.daily_holdings_history)
        df['日期'] = pd.to_datetime(df['日期'])
        df = df[df['持仓类型'] == '期末']

        rebalance_dates = self.custom_matrix.columns.sort_values().tolist()
        df_start_date = df['日期'].min()

        output_path = os.path.join(self.data_path, output_file_name)

        try:
            # 使用 ExcelWriter 写入结果
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                # 为每个调仓周期创建一个sheet
                for i in range(len(rebalance_dates)):
                    if i == 0:
                        start_date = df_start_date
                        end_date = rebalance_dates[i]
                        if end_date < start_date:
                            end_date = start_date
                        period_df = df[(df['日期'] >= start_date) & (df['日期'] <= end_date)]
                        sheet_name = f"周期1_{end_date.strftime('%Y%m%d')}"

                    else:
                        start_date = rebalance_dates[i - 1] + timedelta(days=1)
                        end_date = rebalance_dates[i]
                        period_df = df[(df['日期'] >= start_date) & (df['日期'] <= end_date)]
                        sheet_name = f"周期{i + 1}_{end_date.strftime('%Y%m%d')}"

                    if period_df.empty:
                        print(f"跳过空sheet: {sheet_name} (无数据)")
                        continue

                    pivot_df = period_df.pivot_table(
                        index='股票代码',
                        columns='日期',
                        values='持仓市值',
                        aggfunc='first'
                    ).fillna(0)

                    pivot_df.to_excel(writer, sheet_name=sheet_name)
                    print(f"创建sheet: {sheet_name}, 数据形状: {pivot_df.shape}")

                # 最后一个调仓周期之后的数据
                if rebalance_dates:
                    last_rebalance = rebalance_dates[-1]
                    last_period_df = df[df['日期'] > last_rebalance]
                    if not last_period_df.empty:
                        sheet_name = f"最后周期_{df['日期'].max().strftime('%Y%m%d')}"
                        pivot_df = last_period_df.pivot_table(
                            index='股票代码',
                            columns='日期',
                            values='持仓市值',
                            aggfunc='first'
                        ).fillna(0)
                        pivot_df.to_excel(writer, sheet_name=sheet_name)
                        print(f"创建sheet: {sheet_name}, 数据形状: {pivot_df.shape}")

            print(f"\n成功导出个股持仓市值详情至: {output_path}")

        except Exception as e:
            print(f"\n导出个股持仓市值详情失败: {e}")

    def calculate_metrics(self, daily_returns_df, cumulative_value_df):
        """计算雷达图所需指标，并将结果存储在 self.metrics_results 中。"""
        if daily_returns_df.empty or cumulative_value_df.empty:
            print("每日收益率或累计净值数据为空，无法计算绩效指标。")
            return

        risk_free_rate_daily = 0.015 / 250
        trading_days_per_year = 250

        strategy_col = 'BL优化策略'
        csi_col_daily = 'CSI500_TR_Benchmark_Value'  # 用于相对指标 (全收益为基准)

        total_days = len(daily_returns_df)
        total_return_strategy = (1 + daily_returns_df[strategy_col]).prod() - 1

        annualized_return_strategy = (1 + total_return_strategy) ** (trading_days_per_year / total_days) - 1
        annualized_volatility_strategy = daily_returns_df[strategy_col].std() * np.sqrt(trading_days_per_year)

        cumulative_wealth = cumulative_value_df[strategy_col] / self.initial_capital
        peak = cumulative_wealth.expanding(min_periods=1).max()
        drawdown = (cumulative_wealth / peak) - 1
        max_drawdown = drawdown.min()

        min_wealth = cumulative_wealth.expanding(min_periods=1).min()
        max_gain_series = cumulative_wealth / min_wealth - 1
        max_gain_period = max_gain_series.max()

        sharpe_ratio = (annualized_return_strategy - (
                risk_free_rate_daily * trading_days_per_year)) / annualized_volatility_strategy

        calmar_ratio = annualized_return_strategy / abs(max_drawdown) if abs(max_drawdown) > 0 else np.nan

        tracking_difference = daily_returns_df[strategy_col] - daily_returns_df[csi_col_daily]
        tracking_error = tracking_difference.std() * np.sqrt(trading_days_per_year)

        csi_annual_return = (1 + daily_returns_df[csi_col_daily].prod()) ** (trading_days_per_year / total_days) - 1
        annual_excess_vs_csi = annualized_return_strategy - csi_annual_return
        information_ratio = annual_excess_vs_csi / tracking_error if tracking_error != 0 else np.nan

        win_days = (daily_returns_df[strategy_col] > daily_returns_df[csi_col_daily]).sum()
        relative_win_rate = win_days / total_days

        self.metrics_results = {
            '年化收益率': annualized_return_strategy,
            '年化波动率': annualized_volatility_strategy,
            '区间最大涨幅': max_gain_period,
            '区间最大回撤': abs(max_drawdown),
            '夏普比率': sharpe_ratio,
            'Calmar比率': calmar_ratio,
            '信息比率': information_ratio,
            '相对基准胜率': relative_win_rate
        }

        print("\n" + "=" * 50)
        print("======== 策略绩效指标 (雷达图八项指标) ========")
        print("=" * 50)
        for name, value in self.metrics_results.items():
            if name in ['年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤', '相对基准胜率']:
                print(f"{name}: {value * 100:.2f}%")
            else:
                print(f"{name}: {value:.2f}")
        print("=" * 50)


def plot_performance(results_df, initial_capital=300000000):
    """
    绘制投资组合累积收益率图表，适配BL优化策略和两个CSI500基准。

    Args:
        results_df (pd.DataFrame): 包含策略和基准累计收益率（%）的DataFrame。
        initial_capital (int): 初始资金，用于图表标题显示。
    """
    if results_df is None or results_df.empty:
        print("没有可用于绘制的投资组合回测结果。")
        return

    plt.rcParams['font.sans-serif'] = ['SimHei']  # 设置中文显示
    plt.rcParams['axes.unicode_minus'] = False  # 解决负号'-'显示为方块的问题

    plt.figure(figsize=(12, 7))

    # 策略颜色和标签映射，使用您回测结果中的列名
    strategy_config = {
        'BL优化策略': {'color': 'blue', 'label': 'BL优化策略', 'linestyle': '-', 'linewidth': 2},
        'CSI500_TR_Benchmark': {'color': 'black', 'label': '中证500全收益指数 (TR)', 'linestyle': '--',
                                'linewidth': 2,
                                'alpha': 0.8},
        # 'CSI500_SR_Benchmark': {'color': 'red', 'label': '中证500普通收益指数 (SR)', 'linestyle': ':',
        #                         'linewidth': 2,
        #                         'alpha': 0.8}
    }

    # 1. 绘图循环
    plotted_strategies = []
    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            data = results_df[strategy]
            plt.plot(data.index, data.values,
                     color=config['color'],
                     label=config['label'],
                     linestyle=config['linestyle'],
                     linewidth=config['linewidth'],
                     alpha=config.get('alpha', 1))
            plotted_strategies.append((strategy, config['label']))

    # 2. 设置图表样式

    # 尝试获取 initial_capital，如果全局没有 tester 对象，则使用传入的默认值
    # try:
    #     title_capital = f"初始资金 {initial_capital / 10000:.0f} 万元"
    # except Exception:
    title_capital = "初始资金 30000 万元 "  # 使用您回测中的1000万作为默认

    plt.title(f'BL优化策略 vs. 基准指数 ({title_capital})', fontsize=14, fontweight='bold', pad=15)
    plt.xlabel('日期', fontsize=10)
    plt.ylabel('累积收益率 (%)', fontsize=10)
    plt.legend(fontsize=10, loc='best')
    plt.grid(True, linestyle='--', alpha=0.6)

    # 日期格式化
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
    plt.gcf().autofmt_xdate()

    # 绘制零线
    plt.axhline(y=0, color='red', linestyle='-', alpha=0.5, linewidth=1)
    plt.tight_layout()
    plt.show()

    # 3. 打印最终收益率
    print("\n各策略最终累积收益率统计：")
    for strategy_col, label in plotted_strategies:
        final_return = results_df[strategy_col].iloc[-1]
        print(f"{label}: {final_return:.2f}%")


# =========================================================================
# === 调用函数和执行回测的示例代码 ===
# =========================================================================

if __name__ == '__main__':
    # --- 1. 定义文件路径 (请根据您的实际文件路径修改) ---
    # 假设所有文件都在这个基础目录下
    BASE_DATA_PATH = r"C:\Users\cufet\Desktop\测试集"

    # 股票价格数据文件 (应包含股票价格和您的权重矩阵)
    STOCK_PRICE_FILE = r"中证500成分股数据-快照2.xlsx"

    # 基准数据文件 (假设中证500全收益和普通收益是单独的两个文件)
    # 请注意：您需要确保 BASE_DATA_PATH 中存在这两个文件，且文件内部只有日期和价格两列。
    CSI500_TOTAL_RETURN_FILE = r"C:\Users\cufet\Desktop\测试集\CSI500_TotalReturn.xls"  # 中证500全收益指数数据文件名
    CSI500_SIMPLE_RETURN_FILE = r"C:\Users\cufet\Desktop\测试集\CSI500_SimpleReturn.xls"  # 中证500普通收益指数数据文件名

    # --- 2. 实例化回测器 ---
    try:
        backtester = SimplePortfolioBacktester(
            data_path=BASE_DATA_PATH,
            stock_data_file=STOCK_PRICE_FILE,
            csi_data_file=CSI500_TOTAL_RETURN_FILE,  # 映射到 csi500_tr_data_file
            csi500_simple_data_file=CSI500_SIMPLE_RETURN_FILE  # 映射到 csi500_sr_data_file
        )

    except Exception as e:
        print(f"\n[致命错误] 实例化回测器失败，请检查文件路径和加载逻辑: {e}")
        exit()

    # --- 3. 执行回测 ---
    print("\n" + "#" * 60)
    print("############ 正在执行回测: BL优化策略 ############")
    print("#" * 60)

    # 设置回测区间 (如果需要调整)
    results_df = backtester.run_backtest(
        start_date='2023-01-20',
        end_date='2025-09-30'
    )

    # --- 4. 结果处理 ---
    if results_df is not None and not results_df.empty:
        print("\n--- 最终回测累计收益率 (%) ---")
        print(results_df.tail(1))  # 打印最后一行的累计收益率

        # --- 5. 导出持仓详情 (可选) ---
        backtester._output_holdings_to_excel(
            output_file_name="BL优化策略_持仓市值详情.xlsx"
        )

    else:
        print("\n回测执行失败或结果为空。")
    if results_df is not None and not results_df.empty:
        # 传入回测结果DataFrame
        plot_performance(results_df, initial_capital=backtester.initial_capital)

    print("\n回测程序运行结束。")

