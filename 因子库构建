import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('TkAgg')  # 保留您的TkAgg设置
import matplotlib.pyplot as plt
from pathlib import Path
from typing import Dict, List, Optional, Callable
import warnings
import os
from typing import Dict
from scipy.stats import pearsonr
from sklearn.linear_model import Lasso
import joblib # 导入 joblib 用于保存模型
from sklearn.preprocessing import StandardScaler
# 配置中文显示和警告过滤
matplotlib.rcParams['font.sans-serif'] = ['SimHei', 'Arial']
matplotlib.rcParams['axes.unicode_minus'] = False
warnings.filterwarnings('ignore')


class CS500FactorAnalyzer:

    def __init__(self, data_folder: str):
        self.data_folder = Path(data_folder)
        self.all_data = {}
        self.factor_results = {}
        self.synthetic_factors = {}

    def parse_dirty_wide_table(self, raw_data: pd.DataFrame, sheet_name: str = None) -> pd.DataFrame:
        try:
            data = raw_data.copy()
            # 1. 设置列名为股票代码（第1行，索引 0）
            data.columns = data.iloc[0].values
            # 2. 删除前两行（代码行和名称行）
            clean_data = data.iloc[2:].copy()
            # 3. 设置时间索引（第一列）
            time_col_name = clean_data.columns[0]
            clean_data = clean_data.set_index(time_col_name)
            cleaned_index = [val if not isinstance(val, tuple) else pd.NaT for val in clean_data.index]
            clean_data.index = pd.Index(cleaned_index)
            # 4. 解析时间索引并转为数值
            clean_data.index = pd.to_datetime(clean_data.index)
            # 确保数据列是数值类型，非数值转为 NaN
            clean_data = clean_data.apply(pd.to_numeric, errors='coerce')

            # 5. 清理和统一命名 (先删除全为空的列，再进行填充)
            clean_data = clean_data.dropna(axis=1, how='all')

            # # ==================== 0值和缺失值处理逻辑 (新增/修改) ====================
            # target_sheets = ['ROE', '自由现金流', 'EPS', 'EBITDA']
            clean_data = clean_data.replace(0, np.nan)

            # 2. 对所有 NaN (包括原来的 NaN 和由 0 替换来的 NaN) 执行向前填充 (ffill)
            clean_data = clean_data.fillna(method='ffill')
            # ==================== 0值和缺失值处理逻辑 (结束) ====================

            # 6. 清理和统一命名 (与原有逻辑一致)
            clean_data.columns.name = 'code'
            clean_data.index.name = 'date'

            # if sheet_name:
            #     print(sheet_name)
            #     print(
            #         f"✅ 解析完成: {clean_data.shape}, 时间范围: {clean_data.index.min()} 到 {clean_data.index.max()}")

            return clean_data

        except Exception as e:
            print(f"❌ 解析 {sheet_name} 失败: {e}")
            raise

    def load_all_periods(self):
        """加载所有时间点的数据"""

        # 1. 查找所有匹配的文件 (.xlsx 和 .xls)，并按名称排序
        excel_files = sorted(
            list(self.data_folder.glob("中证500_*.xlsx")) +
            list(self.data_folder.glob("中证500_*.xls"))
        )

        if not excel_files:
            print(
                f"⚠️ 未找到本地 Excel 文件。请检查路径：{self.data_folder} 下是否存在命名为 '中证500_*.xlsx' 或 '中证500_*.xls' 的文件。")
            return

        print(f"找到 {len(excel_files)} 个数据文件")

        for file in excel_files:
            # 【修改 1：提取周期名称，并去掉 "中证500_" 前缀】
            period_name = file.stem.replace("中证500_", "")
            print(f"\n📁 加载: {period_name}")

            try:
                xl_file = pd.ExcelFile(file)
                period_data = {}

                for sheet_name in xl_file.sheet_names:
                    # Sheet1 通常是股票基本信息
                    if sheet_name == 'Sheet1':
                        stock_info = pd.read_excel(file, sheet_name=sheet_name)
                        period_data['stock_info'] = stock_info
                    else:
                        sheet_data = pd.read_excel(file, sheet_name=sheet_name, header=None)
                        try:
                            parsed_data = self.parse_dirty_wide_table(sheet_data, sheet_name)

                            if parsed_data.empty:
                                continue

                            period_data[sheet_name] = parsed_data

                        except Exception:
                            continue

                self.all_data[period_name] = period_data

                # 打印加载成功的因子键
                loaded_keys = [k for k in period_data.keys() if k != 'stock_info']

                # 【修改 3：在加载完成的输出中，也使用去掉前缀的 period_name】
                print(f"    ✅ {period_name} 文件加载完成，包含 {len(loaded_keys)} 个因子数据项。Keys: {loaded_keys}")


            except Exception as e:
                print(f"❌ 加载文件 {file.name} 失败: {e}")

        # 显示数据概览
        if self.all_data:
            self._display_data_overview()
        else:
            print("\n⚠️  没有成功加载任何数据")

    def _display_data_overview(self):
        print(f"\n{'=' * 60}")
        print("数据加载概览")
        print(f"{'=' * 60}")

        for period_name, period_data in self.all_data.items():
            print(f"\n📅 时间段: {period_name}")
    def calculate_synthetic_factor(self, factor_name: str, calculation_func: Callable):
        print(f"\n🔧 计算合成因子: {factor_name}")
        self.synthetic_factors[factor_name] = {}
        success_count = 0
        for period_name, period_data in self.all_data.items():
            try:
                # 传入 period_data (包含所有时间序列宽表)
                factor_data = calculation_func(period_data)

                # 检查返回结果是否为每日时间序列宽表
                if not factor_data.empty and factor_data.index.name == 'date' and factor_data.columns.name == 'code':
                    self.synthetic_factors[factor_name][period_name] = factor_data
                    success_count += 1
                    print(
                        f"   ✅ {period_name}: 计算成功, 每日截面: {len(factor_data)}, 股票数: {len(factor_data.columns)}")
                else:
                    print(f"   ⚠️  {period_name}: 无有效数据或数据格式错误")
            except Exception as e:
                print(f"   ❌ {period_name}: 计算失败 - {e}")

        print(f"📈 {factor_name} 计算完成: {success_count}/{len(self.all_data)} 个时间段")
    def calculate_alpha1(self, period_data: Dict) -> pd.DataFrame:
        if '收盘价' not in period_data or '成交量' not in period_data:
            raise ValueError("缺少收盘价或成交量数据")

        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 确保数据对齐
        common_stocks = close_df.columns.intersection(volume_df.columns)
        close_df = close_df[common_stocks]
        volume_df = volume_df[common_stocks]
        close_rank_cs = close_df.rank(axis=1, pct=True)  # 每天在所有股票中排名
        volume_rank_cs = volume_df.rank(axis=1, pct=True)

        # 1b. 计算这两组排名序列在过去10天的**时间序列**相关性 (rolling(10).corr())
        # 这样计算的是**斯皮尔曼等级相关系数** (Spearman's rank correlation coefficient)
        # 对每只股票，计算其过去10天的 (close_rank_cs, volume_rank_cs) 的相关性。
        corr_term_raw = close_rank_cs.rolling(window=10).corr(volume_rank_cs)

        # --- Step 2: rank(correlation_term) * rank(delta_term) ---

        # 2a. 对相关性项进行**截面**排名: rank(corr_term_raw)
        rank_corr_term = corr_term_raw.rank(axis=1, pct=True)

        # 2b. 滚动计算价格变化项: delta(close, 5)
        delta_term_raw = close_df.diff(5)

        # 2c. 对价格变化项进行**截面**排名: rank(delta(close, 5))
        rank_delta_term = delta_term_raw.rank(axis=1, pct=True)

        # 2d. 组合: rank(correlation(...)) * rank(delta(...))
        raw_factor_df = rank_corr_term * rank_delta_term

        # --- Step 3: 最终因子值 (原始因子值是每日截面值) ---
        # 对最终结果进行截面排名，这是通常的做法，以确保因子值分布统一
        alpha1_df = raw_factor_df.rank(axis=1, pct=True, method='average')

        # 清理和统一命名
        alpha1_df.columns.name = 'code'
        alpha1_df.index.name = 'date'

        # 删除所有股票都是 NaN 的日期
        return alpha1_df.dropna(how='all')

    def calculate_alpha2(self, period_data: Dict) -> pd.DataFrame:
        """
        Alpha#2 (每日滚动): rank(delta(close, 5)) * rank(delta(volume, 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data:
            raise ValueError("缺少收盘价或成交量数据")

        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        common_stocks = close_df.columns.intersection(volume_df.columns)
        close_df = close_df[common_stocks]
        volume_df = volume_df[common_stocks]

        # 1. 5日价格变化: delta(close, 5)
        delta_close = close_df.diff(5)
        # 2. 5日成交量变化: delta(volume, 5)
        delta_volume = volume_df.diff(5)

        # 3. 截面排名 (Cross-sectional Rank): 这是关键！
        # rank(delta(close, 5))
        ranked_delta_close = delta_close.rank(axis=1, pct=True, method='average')
        # rank(delta(volume, 5))
        ranked_delta_volume = delta_volume.rank(axis=1, pct=True, method='average')

        # 4. 最终因子值: 两个排名值的乘积
        alpha2_df = ranked_delta_close * ranked_delta_volume

        alpha2_df.columns.name = 'code'
        alpha2_df.index.name = 'date'

        # 删除所有股票都是 NaN 的日期
        return alpha2_df.dropna(how='all')

    def calculate_alpha3(self, period_data: Dict) -> pd.DataFrame:
        """
        Alpha#3 (每日滚动): rank(stddev(close, 10)) * rank(delta(volume, 5))
        这里我们计算：rank(stddev(close, 10)) * rank(delta(volume, 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data:
            raise ValueError("缺少收盘价或成交量数据")

        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        common_stocks = close_df.columns.intersection(volume_df.columns)
        close_df = close_df[common_stocks]
        volume_df = volume_df[common_stocks]

        # 1. 滚动计算10日波动率: stddev(close, 10)
        volatility_term = close_df.rolling(window=10).std()

        # 2. 滚动计算5日成交量变化: delta(volume, 5)
        delta_volume_term = volume_df.diff(5)

        # 3. 截面排名: 分别对两个项进行每日截面排名
        # rank(stddev(close, 10))
        ranked_volatility = volatility_term.rank(axis=1, pct=True, method='average')

        # rank(delta(volume, 5))
        ranked_delta_volume = delta_volume_term.rank(axis=1, pct=True, method='average')

        # 4. 最终因子值: 两个排名值的乘积
        alpha3_df = ranked_volatility * ranked_delta_volume

        alpha3_df.columns.name = 'code'
        alpha3_df.index.name = 'date'

        return alpha3_df.dropna(how='all')

    def calculate_ROC6(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: ROC6 (6周期价格变化率)
        公式: (收盘价 / N周期前收盘价 - 1) * 100
        """
        if '收盘价' not in period_data:
            raise ValueError("缺少收盘价数据")

        close_df = period_data['收盘价']

        # 计算 N=6 周期前的收盘价
        close_lagged = close_df.shift(6)

        # 计算ROC6
        ROC6_df = ((close_df / close_lagged) - 1) * 100

        # 截面排名 (可选，但通常因子都需要排名或标准化)
        factor_df = ROC6_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')
    def calculate_BIAS60(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: BIAS60 (60周期价格乖离率)
        公式: (收盘价 - 60周期均价) / 60周期均价 * 100
        """
        if '收盘价' not in period_data:
            raise ValueError("缺少收盘价数据")

        close_df = period_data['收盘价']

        # 计算60周期简单移动平均线 (Simple Moving Average, SMA)
        MA60 = close_df.rolling(window=60).mean()

        # 计算BIAS60
        BIAS60_df = ((close_df - MA60) / MA60) * 100

        # 截面排名
        factor_df = BIAS60_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')
    def calculate_CCI20(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: CCI20 (20周期商品通道指数)
        """
        if '收盘价' not in period_data or '日最高价' not in period_data or '日最低价' not in period_data:
            raise ValueError("缺少收盘价、最高价或最低价数据")

        close_df = period_data['收盘价']
        high_df = period_data['日最高价']
        low_df = period_data['日最低价']
        N = 20

        # 1. 计算 Typical Price (TP)
        TP_df = (high_df + low_df + close_df) / 3

        # 2. 计算 TP 的 N 周期 SMA (SMATP)
        SMATP_df = TP_df.rolling(window=N).mean()

        # 3. 计算 N 周期平均绝对偏差 (Mean Deviation)
        # MeanDeviation = SMA(|TP - SMATP|, N)
        MD_df = (TP_df - SMATP_df).abs().rolling(window=N).mean()

        # 4. 计算 CCI
        # 避免除以零
        MD_df_safe = MD_df.replace(0, np.nan)
        CCI20_df = (TP_df - SMATP_df) / (0.015 * MD_df_safe)

        # 截面排名
        factor_df = CCI20_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')
    def calculate_WVAD6(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: WVAD (6周期加权成交量变异度 - 平滑形式)
        公式: SMA( ( (Close - Open) / (High - Low) ) * Volume , 6 )
        """
        if '收盘价' not in period_data or '开盘价' not in period_data or \
                '日最高价' not in period_data or '日最低价' not in period_data or '成交量' not in period_data:
            raise ValueError("缺少价格或成交量数据")

        close_df = period_data['收盘价']
        open_df = period_data['开盘价']
        high_df = period_data['日最高价']
        low_df = period_data['日最低价']
        volume_df = period_data['成交量']
        N = 6

        # 1. 计算核心比率: (Close - Open) / (High - Low)
        # 避免除以零: 当 High=Low 时，该比率为 NaN (或设为0)
        price_range = high_df - low_df
        # 使用 np.divide 安全地执行除法，并用 where 避免除零
        ratio_df = np.divide(close_df - open_df, price_range,
                             out=np.zeros_like(price_range, dtype=float),
                             where=price_range != 0)

        # 2. 计算加权成交量: Ratio * Volume
        weighted_volume = ratio_df * volume_df

        # 3. 计算 N=6 周期移动平均 (SMA)
        WVAD_df = weighted_volume.rolling(window=N).mean()

        # 截面排名
        factor_df = WVAD_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_EP_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: EP (盈利收益率)
        公式: 1 / PE，然后进行截面排名。
        """
        if 'PE' not in period_data:
            raise ValueError("缺少PE数据")

        PE_df = period_data['PE']

        # 避免除零和极端值：PE > 0 才有意义
        EP_df = 1.0 / PE_df.mask(PE_df <= 0)

        # 截面排名 (rank(axis=1))
        factor_df = EP_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_ROE_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: ROE (净资产收益率)
        公式: ROE，然后进行截面排名。
        """
        if 'ROE' not in period_data:
            raise ValueError("缺少ROE数据")

        ROE_df = period_data['ROE']

        # 对ROE进行截面排名
        factor_df = ROE_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_EPS_Growth_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: EPS_Growth (250日EPS增长率)
        公式: (EPS / 250周期前EPS) - 1，然后进行截面排名。
        """
        if 'EPS' not in period_data:
            raise ValueError("缺少EPS数据")

        EPS_df = period_data['EPS']

        # EPS 过去 250 个周期（约一年）前的数值
        EPS_lagged = EPS_df.shift(30)

        # 计算增长率
        growth_df = (EPS_df / EPS_lagged) - 1

        # 截面排名
        factor_df = growth_df.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Turnover20_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        因子: Turnover20 (20日平均换手率)
        公式: 20日换手率的简单移动平均 (SMA)，然后进行截面排名。
        """
        if '换手率' not in period_data:
            raise ValueError("缺少换手率数据")

        turnover_df = period_data['换手率']

        # 计算20日简单移动平均
        SMA_turnover = turnover_df.rolling(window=20).mean()

        # 截面排名
        factor_df = SMA_turnover.rank(axis=1, pct=True)

        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_momentum_value_composite(self, period_data: Dict) -> pd.DataFrame:
        """
        动量-价值复合因子
        公式: rank(ROC20) * rank(1/PE)
        结合中期动量与价值低估
        """
        if '收盘价' not in period_data or 'PE' not in period_data:
            raise ValueError("缺少收盘价或PE数据")

        close_df = period_data['收盘价']
        pe_df = period_data['PE']

        # 20日动量
        roc20 = (close_df / close_df.shift(20) - 1)

        # 价值因子 (盈利收益率)
        ep = 1.0 / pe_df.mask(pe_df <= 0)

        # 复合因子
        composite = roc20.rank(axis=1, pct=True) * ep.rank(axis=1, pct=True)

        factor_df = composite.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_vol_adjusted_value(self, period_data: Dict) -> pd.DataFrame:
        """
        波动率调整价值因子
        公式: rank(EP) / rank(波动率)
        在价值因子上考虑风险调整
        """
        if 'PE' not in period_data or '收盘价' not in period_data:
            raise ValueError("缺少PE或收盘价数据")

        pe_df = period_data['PE']
        close_df = period_data['收盘价']

        # 盈利收益率
        ep = 1.0 / pe_df.mask(pe_df <= 0)

        # 20日波动率
        volatility = close_df.pct_change().rolling(20).std()

        # 波动率调整价值
        vol_adjusted_ep = ep.rank(axis=1, pct=True) / (volatility.rank(axis=1, pct=True) + 1e-6)

        factor_df = vol_adjusted_ep.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_volume_price_divergence(self, period_data: Dict) -> pd.DataFrame:
        """
        量价背离因子
        公式: rank(价格动量) - rank(成交量动量)
        捕捉量价背离的技术信号
        """
        if '收盘价' not in period_data or '成交量' not in period_data:
            raise ValueError("缺少收盘价或成交量数据")

        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 5日价格动量
        price_momentum = close_df.pct_change(5)

        # 5日成交量动量
        volume_momentum = volume_df.pct_change(5)

        # 量价背离
        divergence = price_momentum.rank(axis=1, pct=True) - volume_momentum.rank(axis=1, pct=True)

        factor_df = divergence.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_profitability_growth(self, period_data: Dict) -> pd.DataFrame:
        """
        盈利能力增长因子
        公式: rank(ROE变化率) * rank(EBITDA增长率)
        捕捉盈利能力的改善趋势
        """
        if 'ROE' not in period_data or 'EBITDA' not in period_data:
            raise ValueError("缺少ROE或EBITDA数据")

        roe_df = period_data['ROE']
        ebitda_df = period_data['EBITDA']

        # ROE 60日变化率
        roe_growth = (roe_df / roe_df.shift(60) - 1)

        # EBITDA 60日增长率
        ebitda_growth = (ebitda_df / ebitda_df.shift(60) - 1)

        # 复合增长因子
        growth_factor = roe_growth.rank(axis=1, pct=True) * ebitda_growth.rank(axis=1, pct=True)

        factor_df = growth_factor.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

        # --------------------------------------------------------
        # >>>>>> 新增因子计算方法 (A. 价量趋势与动量因子) <<<<<<
        # --------------------------------------------------------
    def calculate_Momentum_Ranking_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格动量因子 I: rank(delta(close, 5))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        delta_term = close_df.diff(5)
        factor_df = delta_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')



    def calculate_Price_Rate_of_Change_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格变动速率因子 I: (close - close.shift(12)) / close.shift(12)
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        roc_term = (close_df - close_df.shift(12)) / close_df.shift(12)
        factor_df = roc_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Cumulative_Price_Change_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        累积价格变化因子 I: rank(sum(delta(close, 1), 30))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        delta_1 = close_df.diff(1)
        # 30日累计变化 (即近30日涨跌幅)
        sum_delta = delta_1.rolling(window=30).sum()
        factor_df = sum_delta.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Multi_period_Momentum_Overlay_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        多期动量叠加因子 I: rank(delta(close, 5)) * rank(delta(close, 10))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        rank_delta_5 = close_df.diff(5).rank(axis=1, pct=True)
        rank_delta_10 = close_df.diff(10).rank(axis=1, pct=True)
        raw_factor_df = rank_delta_5 * rank_delta_10
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_High_Low_Price_Momentum_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        高低价动量因子 I: rank(delta(close, 5)) * rank(delta(high, 5))
        """
        if '收盘价' not in period_data or '日最高价' not in period_data: raise ValueError("缺少收盘价或最高价数据")
        close_df = period_data['收盘价']
        high_df = period_data['日最高价']
        rank_delta_close_5 = close_df.diff(5).rank(axis=1, pct=True)
        rank_delta_high_5 = high_df.diff(5).rank(axis=1, pct=True)
        raw_factor_df = rank_delta_close_5 * rank_delta_high_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Long_term_Price_Level_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        长期价格水平因子 I: rank(sum(close, 60) / 60)
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma_60 = close_df.rolling(window=60).mean()
        factor_df = ma_60.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Momentum_Indicator_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        动量指标因子 I: close - close.shift(5)
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        momentum_term = close_df - close_df.shift(5)
        factor_df = momentum_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # 注：Price Trend Evaluation Factor I, Aroon Up/Down, Price-Volume Synchronization Factor I, Price-Volume Intensity Factor I, Market Trend Correlation Factor I 涉及市场指数或复杂技术指标，若无市场指数数据，无法准确计算。这里实现**不依赖**市场指数的因子。

    # --- 成交量确认动量因子 (实现可行的部分) ---
    def calculate_Price_Volume_Synchronization_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价量同步性因子 I: rank(delta(close, 5)) * rank(delta(volume, 5))
        (与 Alpha#2 类似，但Alpha#2是两个排名乘积后再排名，这里直接实现公式)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']
        rank_delta_close_5 = close_df.diff(5).rank(axis=1, pct=True)
        rank_delta_volume_5 = volume_df.diff(5).rank(axis=1, pct=True)
        raw_factor_df = rank_delta_close_5 * rank_delta_volume_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Volume_Intensity_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价量强度因子 I: rank(correlation(rank(close), rank(volume), 10)) * rank(delta(close, 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 每日截面排名
        rank_close = close_df.rank(axis=1, pct=True)
        rank_volume = volume_df.rank(axis=1, pct=True)

        # 2. 计算 10 日滚动相关性 (时间序列相关性)
        # 注意：这里计算的是每日截面排名后的**时间序列**相关性
        corr_term_raw = rank_close.rolling(window=10).corr(rank_volume)

        # 3. 对相关性项进行截面排名
        rank_corr_term = corr_term_raw.rank(axis=1, pct=True)

        # 4. rank(delta(close, 5))
        rank_delta_close_5 = close_df.diff(5).rank(axis=1, pct=True)

        # 5. 复合
        raw_factor_df = rank_corr_term * rank_delta_close_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Volume_Gain_Synergy_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价量涨幅协同因子 I: rank(delta(close, 5)) * rank(delta(volume, 5))
        (与 Price-Volume Synchronization Factor I 相同，保留以符合命名要求)
        """
        return self.calculate_Price_Volume_Synchronization_Factor_I(period_data)

    def calculate_Relative_Strength_Volume_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        相对强度成交量因子 I: rank((close - delay(close, 5))) * rank(delta(volume, 10))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. close - delay(close, 5) 即 close_df.diff(5)
        rank_delta_close_5 = close_df.diff(5).rank(axis=1, pct=True)

        # 2. rank(delta(volume, 10))
        rank_delta_volume_10 = volume_df.diff(10).rank(axis=1, pct=True)

        raw_factor_df = rank_delta_close_5 * rank_delta_volume_10
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Volume_Intensity_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        价量强度因子: rank(correlation(rank(close), rank(volume), 20)) * rank(delta(close, 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 每日截面排名
        rank_close = close_df.rank(axis=1, pct=True)
        rank_volume = volume_df.rank(axis=1, pct=True)

        # 2. 计算 20 日滚动相关性
        corr_term_raw = rank_close.rolling(window=20).corr(rank_volume)

        # 3. 对相关性项进行截面排名
        rank_corr_term = corr_term_raw.rank(axis=1, pct=True)

        # 4. rank(delta(close, 5))
        rank_delta_close_5 = close_df.diff(5).rank(axis=1, pct=True)

        # 5. 复合
        raw_factor_df = rank_corr_term * rank_delta_close_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Multi_period_Price_Volume_Momentum_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        多期价量动量因子 I: rank(delta(close, 5)) * rank(delta(volume, 10))
        (与 Relative_Strength_Volume_Factor_I 相同，保留以符合命名要求)
        """
        return self.calculate_Relative_Strength_Volume_Factor_I(period_data)

    def calculate_Price_Volume_Absolute_Synchronization_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价量绝对同步因子 I: rank(abs(delta(close, 5))) * rank(abs(delta(volume, 5)))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        rank_abs_delta_close_5 = close_df.diff(5).abs().rank(axis=1, pct=True)
        rank_abs_delta_volume_5 = volume_df.diff(5).abs().rank(axis=1, pct=True)

        raw_factor_df = rank_abs_delta_close_5 * rank_abs_delta_volume_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Absolute_Price_Volume_Change_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        绝对价量变化因子 I: rank(abs(delta(close, 10))) * rank(abs(delta(volume, 10)))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        rank_abs_delta_close_10 = close_df.diff(10).abs().rank(axis=1, pct=True)
        rank_abs_delta_volume_10 = volume_df.diff(10).abs().rank(axis=1, pct=True)

        raw_factor_df = rank_abs_delta_close_10 * rank_abs_delta_volume_10
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Volume_Movement_Relationship_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价量变动关系因子 I: rank(delta(volume, 5)) * rank(delta(close, 5))
        (与 Price-Volume Synchronization Factor I 相同，保留以符合命名要求)
        """
        return self.calculate_Price_Volume_Synchronization_Factor_I(period_data)

    def calculate_Short_term_Price_Volume_Interaction_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        短期价量互动因子 I: rank(delta(close, 5)) * rank(delta(volume, 5))
        (与 Price-Volume Synchronization Factor I 相同，保留以符合命名要求)
        """
        return self.calculate_Price_Volume_Synchronization_Factor_I(period_data)

    # --------------------------------------------------------
    # >>>>>> 新增因子计算方法 (B. 价量背离与反转因子) <<<<<<
    # --------------------------------------------------------
    def calculate_Price_Volume_Divergence_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        量价背离因子: rank(价格动量) - rank(成交量动量)
        (已在 calculate_volume_price_divergence 中实现，但这里使用新的方法名)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 价格动量 (使用 5日 pct_change)
        price_momentum = close_df.pct_change(5)
        # 成交量动量 (使用 5日 pct_change)
        volume_momentum = volume_df.pct_change(5)

        # 量价背离
        divergence = price_momentum.rank(axis=1, pct=True) - volume_momentum.rank(axis=1, pct=True)

        factor_df = divergence.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Negative_Price_Volume_Correlation_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        负价量相关性因子 I: -1 * correlation(rank(close), rank(volume), 10)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 每日截面排名
        rank_close = close_df.rank(axis=1, pct=True)
        rank_volume = volume_df.rank(axis=1, pct=True)

        # 2. 计算 10 日滚动相关性 (时间序列相关性)
        corr_term_raw = rank_close.rolling(window=10).corr(rank_volume)

        # 3. 计算负相关性
        negative_corr = -1 * corr_term_raw

        factor_df = negative_corr.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # --- 反转信号因子 ---
    def calculate_Market_Reversal_Capture_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        市场反转捕捉因子 I: rank(delta(volume, 5)) * rank(stddev(close, 5))
        (与 Alpha#3 公式类似，但周期不同)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 5日波动率: stddev(close, 5)
        volatility_term = close_df.rolling(window=5).std()

        # 2. 5日成交量变化: delta(volume, 5)
        delta_volume_term = volume_df.diff(5)

        # 3. 截面排名并相乘
        ranked_volatility = volatility_term.rank(axis=1, pct=True, method='average')
        ranked_delta_volume = delta_volume_term.rank(axis=1, pct=True, method='average')

        raw_factor_df = ranked_volatility * ranked_delta_volume
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Market_Reversal_Timing_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        市场反转时机因子 I: rank(abs(delta(close, 10))) * rank(abs(delta(volume, 10)))
        (与 Absolute_Price_Volume_Change_Factor_I 相同，保留以符合命名要求)
        """
        return self.calculate_Absolute_Price_Volume_Change_Factor_I(period_data)

    def calculate_Reversal_Potential_Assessment_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        反转潜力评估因子 I: rank(delta(volume, 5)) * rank(abs(delta(close, 5)))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        rank_abs_delta_close_5 = close_df.diff(5).abs().rank(axis=1, pct=True)
        rank_delta_volume_5 = volume_df.diff(5).rank(axis=1, pct=True)

        raw_factor_df = rank_abs_delta_close_5 * rank_delta_volume_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Pullback_Risk_Identification_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        回调风险识别因子 I: rank(delta(close, 10)) * rank(delta(volume, 10))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        rank_delta_close_10 = close_df.diff(10).rank(axis=1, pct=True)
        rank_delta_volume_10 = volume_df.diff(10).rank(axis=1, pct=True)

        raw_factor_df = rank_delta_close_10 * rank_delta_volume_10
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Reversal_Signal_Strength_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        反转信号强度因子 I: rank(delta(close, 5)) * rank(abs(delta(volume, 5)))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        rank_delta_close_5 = close_df.diff(5).rank(axis=1, pct=True)
        rank_abs_delta_volume_5 = volume_df.diff(5).abs().rank(axis=1, pct=True)

        raw_factor_df = rank_delta_close_5 * rank_abs_delta_volume_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Trend_Reversal_Warning_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        趋势反转预警因子 I: rank(correlation(rank(close), rank(volume), 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 每日截面排名
        rank_close = close_df.rank(axis=1, pct=True)
        rank_volume = volume_df.rank(axis=1, pct=True)

        # 2. 计算 5 日滚动相关性
        corr_term_raw = rank_close.rolling(window=5).corr(rank_volume)

        factor_df = corr_term_raw.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # --------------------------------------------------------
    # >>>>>> 新增因子计算方法 (C. 波动性与风险因子) <<<<<<
    # --------------------------------------------------------
    def calculate_Stock_Volatility_and_Volume_Change_Factor(self, period_data: Dict) -> pd.DataFrame:
        """
        股价波动性与成交量变化因子: rank(stddev(close, 10)) * rank(delta(volume, 5))
        (与 Alpha#3 公式相同，但周期不同)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. 10日波动率: stddev(close, 10)
        volatility_term = close_df.rolling(window=10).std()

        # 2. 5日成交量变化: delta(volume, 5)
        delta_volume_term = volume_df.diff(5)

        # 3. 截面排名并相乘
        ranked_volatility = volatility_term.rank(axis=1, pct=True, method='average')
        ranked_delta_volume = delta_volume_term.rank(axis=1, pct=True, method='average')

        raw_factor_df = ranked_volatility * ranked_delta_volume
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Variance_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格方差因子 I: close.rolling(20).var()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        variance_term = close_df.rolling(window=20).var()
        factor_df = variance_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Market_Uncertainty_Measurement_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        市场不确定性度量因子 I: rank(stddev(close, 10))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        stddev_term = close_df.rolling(window=10).std()
        factor_df = stddev_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Bollinger_Upper_Band_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        布林带上轨因子 I: close.rolling(20).mean() + 2 * close.rolling(20).std()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma = close_df.rolling(window=20).mean()
        std = close_df.rolling(window=20).std()
        upper_band = ma + 2 * std
        # 因子值通常是价格相对于指标的位置，这里计算价格与上轨的差值并排名
        factor_df = (close_df - upper_band).rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Bollinger_Lower_Band_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        布林带下轨因子 I: close.rolling(20).mean() - 2 * close.rolling(20).std()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma = close_df.rolling(window=20).mean()
        std = close_df.rolling(window=20).std()
        lower_band = ma - 2 * std
        # 因子值通常是价格相对于指标的位置，这里计算价格与下轨的差值并排名
        factor_df = (close_df - lower_band).rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Short_term_Volatility_Volume_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        短期波动成交量因子 I: rank(stddev(close, 10)) * rank(delta(volume, 5))
        (与 Stock_Volatility_and_Volume_Change_Factor 相同，保留以符合命名要求)
        """
        return self.calculate_Stock_Volatility_and_Volume_Change_Factor(period_data)

    def calculate_Long_term_Volatility_Volume_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        长期波动成交量因子 I: rank(stddev(close, 20)) * rank(delta(volume, 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        volatility_term = close_df.rolling(window=20).std()  # 20日波动率
        delta_volume_term = volume_df.diff(5)  # 5日成交量变化

        ranked_volatility = volatility_term.rank(axis=1, pct=True)
        ranked_delta_volume = delta_volume_term.rank(axis=1, pct=True)

        raw_factor_df = ranked_volatility * ranked_delta_volume
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volatility_Volume_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        波动成交量因子 I: rank(delta(volume, 10)) * rank(stddev(close, 10))
        (与 Stock_Volatility_and_Volume_Change_Factor 类似，周期有微小差异，这里实现其精确公式)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        volatility_term = close_df.rolling(window=10).std()  # 10日波动率
        delta_volume_term = volume_df.diff(10)  # 10日成交量变化

        ranked_volatility = volatility_term.rank(axis=1, pct=True)
        ranked_delta_volume = delta_volume_term.rank(axis=1, pct=True)

        raw_factor_df = ranked_delta_volume * ranked_volatility
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volatility_Volume_Synergy_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        波动率成交量协同因子 I: rank(stddev(close, 10)) * rank(delta(volume, 10))
        (与 Volatility_Volume_Factor_I 相同，保留以符合命名要求)
        """
        return self.calculate_Volatility_Volume_Factor_I(period_data)

    # --- 分布形态与风险评估因子 (使用 pct_change 进行偏度和峰度计算) ---
    def calculate_Price_Skewness_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格偏度因子 I: close.pct_change().rolling(20).skew()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        skewness_term = close_df.pct_change().rolling(window=20).skew()
        factor_df = skewness_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Kurtosis_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格峰度因子 I: close.pct_change().rolling(20).kurtosis()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        kurtosis_term = close_df.pct_change().rolling(window=20).kurtosis()
        factor_df = kurtosis_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Sharpe_Ratio_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        夏普比率因子 I: mean(pct_change, 20) / stddev(pct_change, 20)
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        returns_df = close_df.pct_change()

        mean_returns = returns_df.rolling(window=20).mean()
        std_returns = returns_df.rolling(window=20).std()

        # 避免除以零
        sharpe_ratio_term = np.divide(mean_returns, std_returns,
                                      out=np.zeros_like(mean_returns, dtype=float),
                                      where=std_returns != 0)

        factor_df = sharpe_ratio_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volatility_Risk_Assessment_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        波动风险评估因子 I: rank(abs(delta(close, 5))) * rank(stddev(volume, 5))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # rank(abs(delta(close, 5)))
        rank_abs_delta_close_5 = close_df.diff(5).abs().rank(axis=1, pct=True)
        # rank(stddev(volume, 5))
        rank_stddev_volume_5 = volume_df.rolling(window=5).std().rank(axis=1, pct=True)

        raw_factor_df = rank_abs_delta_close_5 * rank_stddev_volume_5
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Risk_Return_Balance_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        风险回报平衡因子 I: rank(stddev(close, 5)) * rank(delta(volume, 10))
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        # 1. rank(stddev(close, 5))
        rank_stddev_close_5 = close_df.rolling(window=5).std().rank(axis=1, pct=True)
        # 2. rank(delta(volume, 10))
        rank_delta_volume_10 = volume_df.diff(10).rank(axis=1, pct=True)

        raw_factor_df = rank_stddev_close_5 * rank_delta_volume_10
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Standard_Deviation_Deviation_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        标准差偏离度因子 I: rank((close - mean(close, 30)) / stddev(close, 30))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']

        ma_30 = close_df.rolling(window=30).mean()
        std_30 = close_df.rolling(window=30).std()

        # 避免除以零
        deviation_term = np.divide(close_df - ma_30, std_30,
                                   out=np.zeros_like(close_df, dtype=float),
                                   where=std_30 != 0)

        factor_df = deviation_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # --------------------------------------------------------
    # >>>>>> 新增因子计算方法 (D. 成交量形态因子) <<<<<<
    # --------------------------------------------------------
    # Turnover20 已有 calculate_Turnover20_Factor

    def calculate_Volume_Momentum_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        成交量动量因子 I: rank(delta(volume, 10))
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        delta_term = volume_df.diff(10)
        factor_df = delta_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_High_Volume_Screening_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        高成交量筛选因子 I: rank(delta(volume, 5))
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        delta_term = volume_df.diff(5)
        factor_df = delta_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volume_Rate_of_Change_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        成交量变动速率因子 I: (volume - volume.shift(12)) / volume.shift(12)
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        roc_term = (volume_df - volume_df.shift(12)) / volume_df.shift(12)
        factor_df = roc_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Time_Volume_Moving_Average_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        时间成交量均线因子 I: volume.rolling(6).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ma_term = volume_df.rolling(window=6).mean()
        factor_df = ma_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Time_Volume_Moving_Average_Factor_II(self, period_data: Dict) -> pd.DataFrame:
        """
        时间成交量均线因子 II: volume.rolling(20).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ma_term = volume_df.rolling(window=20).mean()
        factor_df = ma_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volume_Exponential_Moving_Average_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        成交量指数移动平均因子 I: volume.ewm(span=10).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ema_term = volume_df.ewm(span=10).mean()
        factor_df = ema_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volume_Exponential_Moving_Average_Factor_II(self, period_data: Dict) -> pd.DataFrame:
        """
        成交量指数移动平均因子 II: volume.ewm(span=12).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ema_term = volume_df.ewm(span=12).mean()
        factor_df = ema_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Average_Volume_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        平均成交量因子 I: volume.rolling(5).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ma_term = volume_df.rolling(window=5).mean()
        factor_df = ma_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Dynamic_Volume_Ratio_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        动态成交量比率因子 I: volume.rolling(5).mean() / volume.rolling(120).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ma_5 = volume_df.rolling(window=5).mean()
        ma_120 = volume_df.rolling(window=120).mean()

        # 避免除以零
        ratio_term = np.divide(ma_5, ma_120,
                               out=np.zeros_like(ma_5, dtype=float),
                               where=ma_120 != 0)

        factor_df = ratio_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Volume_Difference_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        成交量差值因子 I: volume - volume.rolling(10).mean()
        """
        if '成交量' not in period_data: raise ValueError("缺少成交量数据")
        volume_df = period_data['成交量']
        ma_10 = volume_df.rolling(window=10).mean()
        diff_term = volume_df - ma_10
        factor_df = diff_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # --------------------------------------------------------
    # >>>>>> 新增因子计算方法 (E. 技术指标与市场情绪因子) <<<<<<
    # --------------------------------------------------------
    def calculate_MACD_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        MACD 因子 I: close.ewm(span=12).mean() - close.ewm(span=26).mean() (即 MACD 中的 DIF 线)
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ema_12 = close_df.ewm(span=12, adjust=False).mean()
        ema_26 = close_df.ewm(span=26, adjust=False).mean()
        macd_dif = ema_12 - ema_26
        factor_df = macd_dif.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Commodity_Channel_Index_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        商品通道指数因子 I: 10日CCI指标。 (typical_price - typical_price.rolling(10).mean()) / (0.015 * typical_price.rolling(10).std())
        (与 CCI20 相同，但周期 N=10)
        """
        if '收盘价' not in period_data or '日最高价' not in period_data or '日最低价' not in period_data:
            raise ValueError("缺少收盘价、最高价或最低价数据")

        close_df = period_data['收盘价']
        high_df = period_data['日最高价']
        low_df = period_data['日最低价']
        N = 10

        # 1. 计算 Typical Price (TP)
        TP_df = (high_df + low_df + close_df) / 3

        # 2. 计算 TP 的 N 周期 SMA (SMATP)
        SMATP_df = TP_df.rolling(window=N).mean()

        # 3. 计算 N 周期平均绝对偏差 (Mean Deviation)
        # MeanDeviation = SMA(|TP - SMATP|, N)
        MD_df = (TP_df - SMATP_df).abs().rolling(window=N).mean()

        # 4. 计算 CCI
        MD_df_safe = MD_df.replace(0, np.nan)
        cci_term = (TP_df - SMATP_df) / (0.015 * MD_df_safe)

        factor_df = cci_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # 注：CR Indicator Factor I 和 Money Flow Index Factor I 涉及复杂的价格分解和资金流向计算，暂时跳过，只实现简单指标。

    def calculate_Overbought_Oversold_Indicator_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        超买超卖指标因子 I: rank((close - delay(close, 1))) / rank(stddev(close, 20))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']

        # rank((close - delay(close, 1)))
        rank_delta_1 = close_df.diff(1).rank(axis=1, pct=True)
        # rank(stddev(close, 20))
        rank_stddev_20 = close_df.rolling(window=20).std().rank(axis=1, pct=True)

        # 避免除以零
        indicator_term = np.divide(rank_delta_1, rank_stddev_20,
                                   out=np.zeros_like(rank_delta_1, dtype=float),
                                   where=rank_stddev_20 != 0)

        factor_df = indicator_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # 注：Balance of Power Factor I 涉及开盘价、最高价、最低价和收盘价的复杂关系，若数据项不全或公式复杂，暂不实现。

    def calculate_Price_Bias_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格偏离因子 I: (close - close.rolling(5).mean()) / close.rolling(5).mean()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma_5 = close_df.rolling(window=5).mean()
        # 避免除以零
        bias_term = np.divide(close_df - ma_5, ma_5,
                              out=np.zeros_like(close_df, dtype=float),
                              where=ma_5 != 0)

        factor_df = bias_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Bias_Factor_II(self, period_data: Dict) -> pd.DataFrame:
        """
        价格偏离因子 II: (close - close.rolling(10).mean()) / close.rolling(10).mean()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma_10 = close_df.rolling(window=10).mean()
        # 避免除以零
        bias_term = np.divide(close_df - ma_10, ma_10,
                              out=np.zeros_like(close_df, dtype=float),
                              where=ma_10 != 0)

        factor_df = bias_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Bias_Factor_III(self, period_data: Dict) -> pd.DataFrame:
        """
        价格偏离因子 III: (close - close.rolling(20).mean()) / close.rolling(20).mean()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma_20 = close_df.rolling(window=20).mean()
        # 避免除以零
        bias_term = np.divide(close_df - ma_20, ma_20,
                              out=np.zeros_like(close_df, dtype=float),
                              where=ma_20 != 0)

        factor_df = bias_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Bias_Factor_IV(self, period_data: Dict) -> pd.DataFrame:
        """
        价格偏离因子 IV: (close - close.rolling(60).mean()) / close.rolling(60).mean()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ma_60 = close_df.rolling(window=60).mean()
        # 避免除以零
        bias_term = np.divide(close_df - ma_60, ma_60,
                              out=np.zeros_like(close_df, dtype=float),
                              where=ma_60 != 0)

        factor_df = bias_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Exponential_Moving_Average_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        指数移动平均因子 I: close.ewm(span=5).mean()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        ema_term = close_df.ewm(span=5, adjust=False).mean()
        factor_df = ema_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Weekly_Close_Rank_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        周收盘排名因子 I: close / close.rolling(250).max()
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']
        max_250 = close_df.rolling(window=250).max()
        # 避免除以零
        rank_term = np.divide(close_df, max_250,
                              out=np.zeros_like(close_df, dtype=float),
                              where=max_250 != 0)

        factor_df = rank_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Price_Range_Analysis_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        价格区间分析因子 I: rank(open - close) * rank(high - low)
        """
        if '开盘价' not in period_data or '收盘价' not in period_data or \
                '日最高价' not in period_data or '日最低价' not in period_data:
            raise ValueError("缺少开盘价、收盘价、最高价或最低价数据")

        open_df = period_data['开盘价']
        close_df = period_data['收盘价']
        high_df = period_data['日最高价']
        low_df = period_data['日最低价']

        # rank(open - close)
        rank_open_close = (open_df - close_df).rank(axis=1, pct=True)
        # rank(high - low)
        rank_high_low = (high_df - low_df).rank(axis=1, pct=True)

        raw_factor_df = rank_open_close * rank_high_low
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    # --------------------------------------------------------
    # >>>>>> 新增因子计算方法 (F. 市场联动与相对强弱因子) <<<<<<
    # --------------------------------------------------------
    # 注： Market Relative Strength Factor I, Market Trend Correlation Factor I, Short-term Market Correlation Factor I 涉及市场指数，暂不实现。

    def calculate_Time_Series_Ranking_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        时间序列排名因子 I: rank(Ts_Rank(close, 20))
        """
        if '收盘价' not in period_data: raise ValueError("缺少收盘价数据")
        close_df = period_data['收盘价']

        # Ts_Rank(close, 20) 是指对每只股票，计算其当前收盘价在过去20个交易日中的时间序列排名 (0-19)
        def ts_rank(series, window):
            return series.rolling(window).apply(
                lambda x: x.iloc[-1] in np.sort(x) and np.where(np.sort(x) == x.iloc[-1])[0][0] if len(
                    x) == window else np.nan, raw=False)

        ts_rank_term = close_df.apply(lambda x: x.rolling(window=20).apply(
            lambda y: pd.Series(y.rank(pct=True).iloc[-1]), raw=False
        ), axis=0)

        # 对时间序列排名结果再进行截面排名
        factor_df = ts_rank_term.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')

    def calculate_Relative_Volatility_Factor_I(self, period_data: Dict) -> pd.DataFrame:
        """
        相对波动性因子 I: rank(delta(close, 10)) * rank(delta(volume, 10))
        (与 Pullback_Risk_Identification_Factor_I 相同，保留以符合命名要求)
        """
        if '收盘价' not in period_data or '成交量' not in period_data: raise ValueError("缺少收盘价或成交量数据")
        close_df = period_data['收盘价']
        volume_df = period_data['成交量']

        rank_delta_close_10 = close_df.diff(10).rank(axis=1, pct=True)
        rank_delta_volume_10 = volume_df.diff(10).rank(axis=1, pct=True)

        raw_factor_df = rank_delta_close_10 * rank_delta_volume_10
        factor_df = raw_factor_df.rank(axis=1, pct=True)
        factor_df.columns.name = 'code'
        factor_df.index.name = 'date'
        return factor_df.dropna(how='all')


    def prepare_panel_data(self, factor_name: str) -> pd.DataFrame:
        """
        准备面板数据 (统一处理基础因子和每日滚动合成因子)
        - 将所有时间序列宽表转为长表并合并
        """
        panel_data = []

        for period_name, period_data in self.all_data.items():
            factor_df = None

            # 优先检查合成因子 (现已改为每日滚动计算，返回时间序列宽表)
            if factor_name in self.synthetic_factors and period_name in self.synthetic_factors[factor_name]:
                factor_df = self.synthetic_factors[factor_name][period_name]
            # 其次检查基础因子 (本身就是时间序列宽表)
            elif factor_name in period_data:
                factor_df = period_data[factor_name]

            if factor_df is not None and not factor_df.empty:
                # 使用 stack 将宽表 (Index=date, Columns=code) 转为长表
                try:
                    long_factor_df = factor_df.stack().reset_index()
                    long_factor_df.columns = ['date', 'code', factor_name]
                    long_factor_df['period'] = period_name
                    panel_data.append(long_factor_df)
                except Exception as e:
                    print(f"⚠️  {period_name} - {factor_name} 数据转换失败: {e}")
                    continue

        result_df = pd.concat(panel_data, ignore_index=True) if panel_data else pd.DataFrame()

        if not result_df.empty:
            # 确保日期是 datetime 类型
            result_df['date'] = pd.to_datetime(result_df['date'])
            print(f"\n✅ 因子 '{factor_name}' 面板数据:")
            print(f"   时间点: {result_df['date'].nunique()}")
            print(f"   股票数: {result_df['code'].nunique()}")
            print(f"   总记录: {len(result_df)}")
        else:
            print(f"\n⚠️  因子 '{factor_name}' 无数据")

        return result_df

    def calculate_returns(self) -> pd.DataFrame:
        """计算收益率"""
        returns_data = []

        for period_name, period_data in self.all_data.items():
            if '收盘价' in period_data:
                close_df = period_data['收盘价']
                # 计算日收益率
                returns_df = close_df.pct_change()

                # 将收益率宽表转为长表
                long_returns_df = returns_df.stack().reset_index()
                long_returns_df.columns = ['date', 'code', 'return']
                returns_data.append(long_returns_df)

        result_df = pd.concat(returns_data, ignore_index=True) if returns_data else pd.DataFrame()

        if not result_df.empty:
            # 确保日期是 datetime 类型
            result_df['date'] = pd.to_datetime(result_df['date'])
            # 清理 Inf/-Inf (除以0可能产生)
            result_df = result_df.replace([np.inf, -np.inf], np.nan).dropna(subset=['return'])
            print(f"\n📈 收益率数据: {len(result_df)} 条记录")
        return result_df

    def analyze_factor(self, factor_name: str, plot: bool = False):
        """分析单个因子"""
        print(f"\n{'=' * 60}")
        print(f"🔍 分析因子: {factor_name}")
        print(f"{'=' * 60}")

        # 准备因子数据 (已是每日时间序列)
        factor_df = self.prepare_panel_data(factor_name)
        if factor_df.empty:
            print(f"❌ 因子 {factor_name} 无数据")
            return

        BASE_OUTPUT_DIR = Path("C:/Users/cufet/Desktop/Factor_Analysis_Output")

        # 确保目录存在
        BASE_OUTPUT_DIR.mkdir(exist_ok=True)

        # 完整的绝对文件路径
        excel_path = BASE_OUTPUT_DIR / f"{factor_name}_panel_data.xlsx"

        try:
            factor_df.to_excel(excel_path, index=False)
            print(f"💾 因子面板数据已保存到绝对路径: {excel_path.resolve()}")
        except Exception as e:
            print(f"❌ 保存因子面板数据失败，请检查路径权限: {e}")

        # 准备收益数据
        returns_df = self.calculate_returns()

        # 合并数据
        # 统一列名以供下一步分析
        merged_data = factor_df.merge(returns_df, on=['date', 'code'], how='inner')

        if merged_data.empty:
            print("❌ 无有效数据用于分析")
            dates = factor_df['date'].unique()
            if len(dates) <= 1:
                print("提示：当前数据集中交易日过少，无法进行 T->T+1 的时间序列分析。")
            return

        print(f"✅ 合并数据: {len(merged_data)} 条记录")
        print(f"   时间范围: {merged_data['date'].min()} 到 {merged_data['date'].max()}")
        print(f"   股票数量: {merged_data['code'].nunique()}")

        # 执行分析
        results, daily_returns = self._perform_analysis(merged_data, factor_name)

        # 可视化
        if plot:
            self._create_plots(results, factor_name, merged_data)
            if 'long_short_returns' in daily_returns and not daily_returns['long_short_returns'].empty:
                self._plot_cumulative_return(daily_returns['long_short_returns'], factor_name)

        self.factor_results[factor_name] = results
        return results

    def _perform_analysis(self, data: pd.DataFrame, factor_name: str) -> tuple[Dict, Dict]:
        """执行因子分析 (已修复 T->T+1 匹配逻辑, 增加IC自相关性和多空组合收益序列)"""
        results = {}
        daily_returns = {}  # 用于存储多空组合每日收益序列

        # IC分析
        ic_series = []
        Rankic_series = []
        # 获取所有唯一的、按升序排列的日期
        dates = sorted(data['date'].unique())

        # 用于分档分析 (每日多空收益)
        long_short_daily_returns = []

        # 注意：这里 date[i] 是因子日期 T，date[i+1] 是收益率日期 T+1
        for i in range(len(dates) - 1):
            current_date = dates[i]
            next_date = dates[i + 1]

            # T 日的因子值
            current_factors = data[data['date'] == current_date][['code', factor_name]].copy()
            # T+1 日的收益率
            next_returns = data[data['date'] == next_date][['code', 'return']].copy()

            # 合并 T 日因子和 T+1 日收益
            merged = current_factors.merge(next_returns, on='code', how='inner')

            if len(merged) > 20:  # 最小股票数量要求 (为分档多空留出余量)
                # --- RankIC 计算 ---
                ic = merged[factor_name].corr(merged['return'], method='pearson')
                Rankic = merged[factor_name].corr(merged['return'], method='spearman')
                if not np.isnan(ic):
                    ic_series.append(ic)
                if not np.isnan(Rankic):
                    Rankic_series.append(Rankic)

                # --- 分档多空收益计算 ---
                try:
                    # T日分档
                    merged['decile'] = pd.qcut(
                        merged[factor_name], 5, labels=False, duplicates='drop'
                    )

                    # 确保分档在 0-9 之间
                    if merged['decile'].min() == 0 and merged['decile'].max() == 4:
                        # 最高档 (9) 平均收益 - 最低档 (0) 平均收益
                        return_4 = merged[merged['decile'] == 4]['return'].mean()
                        return_0 = merged[merged['decile'] == 0]['return'].mean()
                        long_short_return = return_4 - return_0
                        long_short_daily_returns.append(pd.Series(long_short_return, index=[next_date]))
                except Exception:
                    # 可能数据不足导致分档失败，跳过这一天
                    pass

        if ic_series:
            # IC序列的索引应该对应收益率日期 (T+1 日)
            ic_series = pd.Series(ic_series, index=dates[1:len(ic_series) + 1])
            ic_series = ic_series[(ic_series != 0) & (ic_series.notna()) & (ic_series != '')]
            monthly_ic_mean = ic_series.resample('M').mean()
            annual_ic_mean = ic_series.resample('Y').mean()
            Rankic_series = pd.Series(Rankic_series, index=dates[1:len(Rankic_series) + 1])
            Rankic_series = Rankic_series[(Rankic_series != 0) & (ic_series.notna()) & (Rankic_series != '')]
            results['ic_series'] = ic_series
            results['annual_ic_mean'] = annual_ic_mean.mean()
            results['monthly_ic_mean'] = monthly_ic_mean.mean()
            results['Rankic_series'] = Rankic_series
            results['ic_mean'] = ic_series.mean()
            results['Rankic_mean'] = Rankic_series.mean()
            results['ic_std'] = ic_series.std()
            results['ir'] = results['ic_mean'] / results['ic_std'] if results['ic_std'] != 0 else 0
            results['win_rate'] = (ic_series > 0).mean() if results['ic_mean'] >= 0 else (ic_series < 0).mean()
            results['factor_direction'] = '正因子' if results['ic_mean'] > 0 else '负因子'

            # 补充：IC 自相关性
            autocorr_1 = self._calculate_ic_autocorrelation(ic_series, lag=1)
            results['ic_autocorr_1'] = autocorr_1

            print(f"📊 IC分析结果:")
            print(f"   IC均值: {results['ic_mean']:.4f}")
            print(f"   月度IC均值: {results['monthly_ic_mean']:.4f}")
            print(f"   年度IC均值: {results['annual_ic_mean']:.4f}")
            print(f"   RankIC均值: {results['Rankic_mean']:.4f}")
            # print(f"   IC标准差: {results['ic_std']:.4f}")
            print(f"   IR: {results['ir']:.3f}")
            print(f"   胜率: {results['win_rate']:.2%}")
            print(f"   IC自相关性 (Lag 1): {autocorr_1:.4f}")
            print(f"   因子方向: {results['factor_direction']}")

        # 每日多空组合收益序列
        if long_short_daily_returns:
            daily_returns['long_short_returns'] = pd.concat(long_short_daily_returns)

        # 分档分析 (与 IC 分析使用相同的 T->T+1 错位逻辑)
        decile_returns_mean = self._decile_analysis_mean(data, factor_name)
        if decile_returns_mean is not None:
            results['decile_returns_mean'] = decile_returns_mean
            results['monotonicity'] = self._calculate_monotonicity(decile_returns_mean)
            print(f"   单调性: {results['monotonicity']:.3f}")

        return results, daily_returns

    def _calculate_ic_autocorrelation(self, ic_series: pd.Series, lag: int = 1) -> float:
        """
        计算 IC 序列的自相关性
        """
        if len(ic_series) <= lag:
            return 0.0
        # 将序列错位 lag 期
        lagged_ic = ic_series.shift(lag)
        # 计算 Pearson 相关系数 (IC 值本身就是数值，用 Pearson 即可)
        # 排除 NaN 值
        valid_data = pd.DataFrame({'ic': ic_series, 'lagged_ic': lagged_ic}).dropna()

        if len(valid_data) < 2:
            return 0.0

        corr, _ = pearsonr(valid_data['ic'], valid_data['lagged_ic'])
        return corr

    def _decile_analysis_mean(self, data: pd.DataFrame, factor_name: str) -> Optional[pd.Series]:
        """分档组合分析 (返回所有期平均收益)"""
        try:
            all_decile_returns = []
            dates = sorted(data['date'].unique())

            for i in range(len(dates) - 1):
                # T 日的因子数据
                current_data = data[data['date'] == dates[i]].copy()
                # T+1 日的收益数据
                next_data = data[data['date'] == dates[i + 1]]

                if len(current_data) < 20:  # 最少20只股票
                    continue

                # 当前期分档 (T日)
                # 使用 labels=False 返回分档数字 0-9
                current_data['decile'] = pd.qcut(
                    current_data[factor_name], 5, labels=False, duplicates='drop'
                )

                # 合并下一期收益 (T+1日)
                merged = current_data.merge(
                    next_data[['code', 'return']], on='code', suffixes=('', '_next'), how='inner'
                )

                if not merged.empty:
                    # 计算每个分档在 T+1 日的平均收益
                    decile_return = merged.groupby('decile')['return_next'].mean()
                    all_decile_returns.append(decile_return)

            if all_decile_returns:
                # 对所有时间段的平均收益取平均
                # 重新设置索引名
                mean_returns = pd.DataFrame(all_decile_returns).mean()
                mean_returns.index = [f'Decile {i + 1}' for i in mean_returns.index]
                return mean_returns

        except Exception as e:
            print(f"分档分析错误: {e}")

        return None

    def _calculate_monotonicity(self, decile_returns: pd.Series) -> float:
        """计算单调性"""
        if len(decile_returns) < 2:
            return 0
        # 对分档数字 (0, 1, ..., 9) 和平均收益进行相关性分析
        ranks = np.arange(len(decile_returns))
        correlation = np.corrcoef(ranks, decile_returns.values)[0, 1]
        return correlation if not np.isnan(correlation) else 0

    def _create_plots(self, results: Dict, factor_name: str, data: pd.DataFrame):
        # 简洁三色配色
        colors = ['#1f77b4', '#d62728', '#7f7f7f']  # 蓝色、红色、灰色
        # 图：分档组合收益柱状图
        if 'decile_returns_mean' in results and len(results['decile_returns_mean']) > 0:
            plt.figure(figsize=(10, 7))  # 增加图表尺寸，为标签留出更多空间
            decile_returns = results['decile_returns_mean']
            x_labels = [i for i in range(1, len(decile_returns) + 1)]
            # 平均日收益转年化收益
            annualized_returns = (1 + decile_returns.values) ** 252 - 1
            y_data_percent = annualized_returns * 100  # 年化百分比收益

            bar_width = 1.0
            bars = plt.bar(x_labels, y_data_percent,
                           width=bar_width,
                           color=colors[0], alpha=1, edgecolor='white', linewidth=0.5)

            # 负收益柱子用红色
            for i, bar in enumerate(bars):
                height = bar.get_height()
                if height < 0:
                    bar.set_color(colors[1])

            # --- 核心修改：标签位置优化 (防止重叠) ---
            # 确定图表的Y轴实际数据显示范围，为标签偏移量提供参考
            y_min_data, y_max_data = np.min(y_data_percent), np.max(y_data_percent)
            y_data_span = y_max_data - y_min_data

            # 设置一个基于数据范围的动态最小偏移量
            # 确保即使数据量很小，标签也能有清晰的间距
            min_label_offset = max(y_data_span * 0.03, 0.005)  # 最小偏移量为数据范围的3%或0.005%

            for i, bar in enumerate(bars):
                height = bar.get_height()

                # 标签文本
                label_text = f'{height:.2f}%'

                # 根据柱子高度正负，决定标签的垂直对齐和初始偏移方向
                if height >= 0:
                    va = 'bottom'
                    # 标签放在柱子上方的固定偏移量
                    offset = min_label_offset
                else:
                    va = 'top'
                    # 标签放在柱子下方的固定偏移量
                    offset = -min_label_offset

                # 如果柱子高度为0，特殊处理标签位置，直接在0线稍上方显示
                if np.isclose(height, 0, atol=0.001):  # 使用 np.isclose 处理浮点数接近0的情况
                    label_text = '0.00%'
                    va = 'bottom'
                    offset = min_label_offset  # 确保在0线之上

                # 绘制标签
                plt.text(bar.get_x() + bar.get_width() / 2, height + offset,
                         label_text, ha='center', va=va,
                         fontsize=10,
                         color='black'  # 统一标签颜色
                         )

            plt.xlim(0.5, len(decile_returns) + 0.5)

            # --- 关键修改 2: 优化Y轴范围和刻度 ---
            # 确保Y轴包含所有数据点和其标签
            # 获取所有标签的y位置，以便确定一个合适的Y轴上限
            all_y_labels_pos = []
            for i, bar in enumerate(bars):
                height = bar.get_height()
                if height >= 0:
                    all_y_labels_pos.append(height + min_label_offset)
                else:
                    all_y_labels_pos.append(height - min_label_offset)

            # 结合数据本身的范围和标签的最高/最低位置来设置Y轴
            current_y_min = y_min_data
            current_y_max = y_max_data

            # 如果有标签，确保Y轴能覆盖所有标签
            if all_y_labels_pos:
                current_y_max = max(current_y_max, np.max(all_y_labels_pos))
                current_y_min = min(current_y_min, np.min(all_y_labels_pos))

            # 增加额外的上下边距，使图表不拥挤
            # 根据实际数据范围动态调整 Y 轴的上下边界
            # 避免当所有收益都集中在狭窄区间时，图表仍然显得太空
            y_range_padding = (current_y_max - current_y_min) * 0.15  # 增加15%的上下边距

            # 确保 Y 轴下限不会过高，如果所有值都是正数，确保能看到0线
            y_lower_bound = min(current_y_min - y_range_padding,
                                0 if y_min_data > 0 else current_y_min - y_range_padding)
            y_upper_bound = current_y_max + y_range_padding

            if y_lower_bound == y_upper_bound:  # 避免除零错误或范围为0
                y_lower_bound -= 0.1
                y_upper_bound += 0.1

            plt.ylim(y_lower_bound, y_upper_bound)

            # 移除Y轴刻度标签，因为我们已经有柱顶标签
            plt.yticks([])

            plt.title(f'分档组合平均收益 - {factor_name}', fontsize=16, fontweight='bold', pad=20)  # 增加标题与图表的间距
            plt.xlabel('分档 (1:最低, 5:最高)', fontsize=12)
            plt.ylabel('年化平均收益 (%)', fontsize=12)
            plt.xticks(x_labels, fontsize=5)  # 确保X轴刻度是 1 到 10
            plt.axhline(y=0, color='black', linewidth=1)  # 0线
            plt.grid(False)  # 移除背景网格

            # 调整布局，防止元素重叠
            plt.tight_layout()

            # 保存到桌面
            save_path = f'C:/Users/cufet/Desktop/{factor_name}_分档收益.png'
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            plt.close()

            print(f"✅ 图表已保存到桌面: {save_path}")
    #
    def _plot_cumulative_return(self, daily_long_short_returns: pd.Series, factor_name: str):
        """
        绘制多空组合的累计走势图 (净值曲线)
        """
        # 计算累计收益率 (净值曲线：(1 + R1) * (1 + R2) * ... - 1)
        # R = daily_returns
        # 净值 = (1 + R).cumprod()
        cumulative_returns = (1 + daily_long_short_returns).cumprod()

        plt.figure(figsize=(10, 6))

        # 绘制净值曲线
        plt.plot(cumulative_returns.index, cumulative_returns.values,
                 color='#d62728', linewidth=2, label='多空组合净值')

        plt.title(f'多空组合累计净值走势 - {factor_name}', fontsize=14, fontweight='bold')
        plt.xlabel('日期')
        plt.ylabel('累计净值')
        plt.grid(False, alpha=0)
        plt.legend()

        # 格式化x轴日期
        plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%Y-%m-%d'))
        plt.gcf().autofmt_xdate()  # 自动旋转日期标签

        # 保存到桌面
        plt.savefig(f'C:/Users/cufet/Desktop/{factor_name}_累计走势图.png', dpi=300, bbox_inches='tight')
        plt.close()

        print(f"✅ 图表已保存到桌面: {factor_name}_累计走势图.png")


def main():
    analyzer = CS500FactorAnalyzer(data_folder="C:/Users/cufet/Desktop/训练集")
    analyzer.load_all_periods()
    # 可选：检查加载的数据
    print(analyzer.all_data.keys())
    print("\n🔧 开始计算合成因子...")
    # Alpha因子的计算逻辑已修改为每日滚动
    analyzer.calculate_synthetic_factor("Alpha#1", analyzer.calculate_alpha1)
    analyzer.calculate_synthetic_factor("Alpha#2", analyzer.calculate_alpha2)
    analyzer.calculate_synthetic_factor("Alpha#3", analyzer.calculate_alpha3)
    analyzer.calculate_synthetic_factor("ROC6", analyzer.calculate_ROC6)
    analyzer.calculate_synthetic_factor("BIAS60", analyzer.calculate_BIAS60)
    analyzer.calculate_synthetic_factor("CCI20", analyzer.calculate_CCI20)
    analyzer.calculate_synthetic_factor("WVAD6", analyzer.calculate_WVAD6)
    analyzer.calculate_synthetic_factor("EP", analyzer.calculate_EP_Factor)
    analyzer.calculate_synthetic_factor("ROE", analyzer.calculate_ROE_Factor)
    analyzer.calculate_synthetic_factor("EPS增长", analyzer.calculate_EPS_Growth_Factor)
    analyzer.calculate_synthetic_factor("Turnover20", analyzer.calculate_Turnover20_Factor)
    analyzer.calculate_synthetic_factor("动量价值复合", analyzer.calculate_momentum_value_composite)
    analyzer.calculate_synthetic_factor("波动调整价值", analyzer.calculate_vol_adjusted_value)
    analyzer.calculate_synthetic_factor("量价背离", analyzer.calculate_volume_price_divergence)
    analyzer.calculate_synthetic_factor("盈利增长", analyzer.calculate_profitability_growth)
    analyzer.calculate_synthetic_factor("Alpha#1", analyzer.calculate_alpha1)
    analyzer.calculate_synthetic_factor("Alpha#2", analyzer.calculate_alpha2)
    analyzer.calculate_synthetic_factor("Alpha#3", analyzer.calculate_alpha3)
    analyzer.calculate_synthetic_factor("ROC6", analyzer.calculate_ROC6)
    analyzer.calculate_synthetic_factor("BIAS60", analyzer.calculate_BIAS60)
    analyzer.calculate_synthetic_factor("CCI20", analyzer.calculate_CCI20)
    analyzer.calculate_synthetic_factor("WVAD6", analyzer.calculate_WVAD6)
    analyzer.calculate_synthetic_factor("EP", analyzer.calculate_EP_Factor)
    analyzer.calculate_synthetic_factor("ROE", analyzer.calculate_ROE_Factor)
    analyzer.calculate_synthetic_factor("EPS增长", analyzer.calculate_EPS_Growth_Factor)
    analyzer.calculate_synthetic_factor("Turnover20", analyzer.calculate_Turnover20_Factor)
    analyzer.calculate_synthetic_factor("动量价值复合", analyzer.calculate_momentum_value_composite)
    analyzer.calculate_synthetic_factor("波动调整价值", analyzer.calculate_vol_adjusted_value)
    analyzer.calculate_synthetic_factor("量价背离", analyzer.calculate_volume_price_divergence)
    analyzer.calculate_synthetic_factor("盈利增长", analyzer.calculate_profitability_growth)
    analyzer.calculate_synthetic_factor("动量排名因子 I", analyzer.calculate_Momentum_Ranking_Factor_I)
    analyzer.calculate_synthetic_factor("价格变动速率因子 I", analyzer.calculate_Price_Rate_of_Change_Factor_I)
    analyzer.calculate_synthetic_factor("累积价格变化因子 I", analyzer.calculate_Cumulative_Price_Change_Factor_I)
    analyzer.calculate_synthetic_factor("多期动量叠加因子 I", analyzer.calculate_Multi_period_Momentum_Overlay_Factor_I)
    analyzer.calculate_synthetic_factor("高低价动量因子 I", analyzer.calculate_High_Low_Price_Momentum_Factor_I)
    analyzer.calculate_synthetic_factor("长期价格水平因子 I", analyzer.calculate_Long_term_Price_Level_Factor_I)
    analyzer.calculate_synthetic_factor("动量指标因子 I", analyzer.calculate_Momentum_Indicator_Factor_I)

    analyzer.calculate_synthetic_factor("价量同步性因子 I", analyzer.calculate_Price_Volume_Synchronization_Factor_I)
    analyzer.calculate_synthetic_factor("价量强度因子 I", analyzer.calculate_Price_Volume_Intensity_Factor_I)
    analyzer.calculate_synthetic_factor("价量涨幅协同因子 I", analyzer.calculate_Price_Volume_Gain_Synergy_Factor_I)
    analyzer.calculate_synthetic_factor("相对强度成交量因子 I", analyzer.calculate_Relative_Strength_Volume_Factor_I)
    analyzer.calculate_synthetic_factor("价量强度因子", analyzer.calculate_Price_Volume_Intensity_Factor)
    analyzer.calculate_synthetic_factor("多期价量动量因子 I",
                                        analyzer.calculate_Multi_period_Price_Volume_Momentum_Factor_I)
    analyzer.calculate_synthetic_factor("价量绝对同步因子 I",
                                        analyzer.calculate_Price_Volume_Absolute_Synchronization_Factor_I)
    analyzer.calculate_synthetic_factor("绝对价量变化因子 I", analyzer.calculate_Absolute_Price_Volume_Change_Factor_I)
    analyzer.calculate_synthetic_factor("价量变动关系因子 I",
                                        analyzer.calculate_Price_Volume_Movement_Relationship_Factor_I)
    analyzer.calculate_synthetic_factor("短期价量互动因子 I",
                                        analyzer.calculate_Short_term_Price_Volume_Interaction_Factor_I)

    analyzer.calculate_synthetic_factor("量价背离因子", analyzer.calculate_Price_Volume_Divergence_Factor)
    analyzer.calculate_synthetic_factor("负价量相关性因子 I",
                                        analyzer.calculate_Negative_Price_Volume_Correlation_Factor_I)
    analyzer.calculate_synthetic_factor("市场反转捕捉因子 I", analyzer.calculate_Market_Reversal_Capture_Factor_I)
    analyzer.calculate_synthetic_factor("市场反转时机因子 I", analyzer.calculate_Market_Reversal_Timing_Factor_I)
    analyzer.calculate_synthetic_factor("反转潜力评估因子 I", analyzer.calculate_Reversal_Potential_Assessment_Factor_I)
    analyzer.calculate_synthetic_factor("回调风险识别因子 I", analyzer.calculate_Pullback_Risk_Identification_Factor_I)
    analyzer.calculate_synthetic_factor("反转信号强度因子 I", analyzer.calculate_Reversal_Signal_Strength_Factor_I)
    analyzer.calculate_synthetic_factor("趋势反转预警因子 I", analyzer.calculate_Trend_Reversal_Warning_Factor_I)

    analyzer.calculate_synthetic_factor("股价波动性与成交量变化因子",
                                        analyzer.calculate_Stock_Volatility_and_Volume_Change_Factor)
    analyzer.calculate_synthetic_factor("价格方差因子 I", analyzer.calculate_Price_Variance_Factor_I)
    analyzer.calculate_synthetic_factor("市场不确定性度量因子 I",
                                        analyzer.calculate_Market_Uncertainty_Measurement_Factor_I)
    analyzer.calculate_synthetic_factor("布林带上轨因子 I", analyzer.calculate_Bollinger_Upper_Band_Factor_I)
    analyzer.calculate_synthetic_factor("布林带下轨因子 I", analyzer.calculate_Bollinger_Lower_Band_Factor_I)
    analyzer.calculate_synthetic_factor("短期波动成交量因子 I",
                                        analyzer.calculate_Short_term_Volatility_Volume_Factor_I)
    analyzer.calculate_synthetic_factor("长期波动成交量因子 I", analyzer.calculate_Long_term_Volatility_Volume_Factor_I)
    analyzer.calculate_synthetic_factor("波动成交量因子 I", analyzer.calculate_Volatility_Volume_Factor_I)
    analyzer.calculate_synthetic_factor("波动率成交量协同因子 I", analyzer.calculate_Volatility_Volume_Synergy_Factor_I)
    analyzer.calculate_synthetic_factor("价格偏度因子 I", analyzer.calculate_Price_Skewness_Factor_I)
    analyzer.calculate_synthetic_factor("价格峰度因子 I", analyzer.calculate_Price_Kurtosis_Factor_I)
    analyzer.calculate_synthetic_factor("夏普比率因子 I", analyzer.calculate_Sharpe_Ratio_Factor_I)
    analyzer.calculate_synthetic_factor("波动风险评估因子 I", analyzer.calculate_Volatility_Risk_Assessment_Factor_I)
    analyzer.calculate_synthetic_factor("风险回报平衡因子 I", analyzer.calculate_Risk_Return_Balance_Factor_I)
    analyzer.calculate_synthetic_factor("标准差偏离度因子 I", analyzer.calculate_Standard_Deviation_Deviation_Factor_I)

    analyzer.calculate_synthetic_factor("成交量动量因子 I", analyzer.calculate_Volume_Momentum_Factor_I)
    analyzer.calculate_synthetic_factor("高成交量筛选因子 I", analyzer.calculate_High_Volume_Screening_Factor_I)
    analyzer.calculate_synthetic_factor("成交量变动速率因子 I", analyzer.calculate_Volume_Rate_of_Change_Factor_I)
    analyzer.calculate_synthetic_factor("时间成交量均线因子 I", analyzer.calculate_Time_Volume_Moving_Average_Factor_I)
    analyzer.calculate_synthetic_factor("时间成交量均线因子 II",
                                        analyzer.calculate_Time_Volume_Moving_Average_Factor_II)
    analyzer.calculate_synthetic_factor("成交量指数均线因子 I",
                                        analyzer.calculate_Volume_Exponential_Moving_Average_Factor_I)
    analyzer.calculate_synthetic_factor("成交量指数均线因子 II",
                                        analyzer.calculate_Volume_Exponential_Moving_Average_Factor_II)
    analyzer.calculate_synthetic_factor("平均成交量因子 I", analyzer.calculate_Average_Volume_Factor_I)
    analyzer.calculate_synthetic_factor("动态成交量比率因子 I", analyzer.calculate_Dynamic_Volume_Ratio_Factor_I)
    analyzer.calculate_synthetic_factor("成交量差值因子 I", analyzer.calculate_Volume_Difference_Factor_I)
    analyzer.calculate_synthetic_factor("MACD 因子 I", analyzer.calculate_MACD_Factor_I)
    analyzer.calculate_synthetic_factor("商品通道指数因子 I", analyzer.calculate_Commodity_Channel_Index_Factor_I)
    analyzer.calculate_synthetic_factor("超买超卖指标因子 I", analyzer.calculate_Overbought_Oversold_Indicator_Factor_I)
    analyzer.calculate_synthetic_factor("价格偏离因子 I", analyzer.calculate_Price_Bias_Factor_I)
    analyzer.calculate_synthetic_factor("价格偏离因子 II", analyzer.calculate_Price_Bias_Factor_II)
    analyzer.calculate_synthetic_factor("价格偏离因子 III", analyzer.calculate_Price_Bias_Factor_III)
    analyzer.calculate_synthetic_factor("价格偏离因子 IV", analyzer.calculate_Price_Bias_Factor_IV)
    analyzer.calculate_synthetic_factor("指数移动平均因子 I", analyzer.calculate_Exponential_Moving_Average_Factor_I)
    analyzer.calculate_synthetic_factor("周收盘排名因子 I", analyzer.calculate_Weekly_Close_Rank_Factor_I)
    analyzer.calculate_synthetic_factor("价格区间分析因子 I", analyzer.calculate_Price_Range_Analysis_Factor_I)
    analyzer.calculate_synthetic_factor("时间序列排名因子 I", analyzer.calculate_Time_Series_Ranking_Factor_I)
    analyzer.calculate_synthetic_factor("相对波动性因子 I", analyzer.calculate_Relative_Volatility_Factor_I)

    print("\n--- 3. 执行所有因子分析并输出结果 ---")

    # 获取所有因子名称的列表
    all_factor_names = list(analyzer.synthetic_factors.keys())

    # 循环遍历所有因子进行分析
    for factor_name in all_factor_names:
        # 设置默认 plot=False
        should_plot = False

        # 特别处理您指定需要绘图的因子
        if factor_name == '价格偏度因子 I':
            should_plot = True

        print(f"  > 正在分析因子: {factor_name} (plot={should_plot})")

        # 执行分析
        analyzer.analyze_factor(factor_name, plot=should_plot)

    print("\n🎉 所有因子的计算和分析已完成！分析报告已保存到 Excel。")

    global all_factors

if __name__ == "__main__":
    main()


