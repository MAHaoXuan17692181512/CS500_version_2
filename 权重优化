import pandas as pd
import numpy as np
import cvxpy as cp
from scipy.stats import zscore


# --- 辅助函数：生成和为 1 的随机权重向量 (保持不变) ---
def generate_random_weights(n):
    """生成一个长度为 n，且元素之和为 1 的随机正数向量。"""
    random_numbers = np.random.rand(n)
    weights = random_numbers / np.sum(random_numbers)
    return weights


# 文件路径统一为您的 BL 后验结果文件
BL_RESULTS_FILE_PATH = r"C:\Users\cufet\Desktop\BL后验结果.xlsx"

# --------------------------------------------------------------------------------------
# 注意：为解决资产数量变化的问题，all_optimal_weights 现在将存储 Series 而不是 NumPy 数组
# --------------------------------------------------------------------------------------
all_optimal_weights = {}
w_before = None  # 上期权重初始化为 None

# ... (代码的其他部分，包括参数设置和数据读取，保持不变) ...

lambda_value = 3
DATE_COLS = [
    "2023-01-01", "2023-01-21", "2023-02-10", "2023-03-02", "2023-03-22", "2023-04-11",
    "2023-05-01", "2023-05-21", "2023-06-10", "2023-06-30", "2023-07-02", "2023-07-22",
    "2023-08-11", "2023-08-31", "2023-09-20", "2023-10-10", "2023-10-30", "2023-11-19",
    "2023-12-09", "2023-12-29", "2023-12-31", "2024-01-20", "2024-02-09", "2024-02-29",
    "2024-03-20", "2024-04-09", "2024-04-29", "2024-05-19", "2024-06-08", "2024-06-28",
    "2024-07-07", "2024-07-27", "2024-08-16", "2024-09-05", "2024-09-25", "2024-10-15",
    "2024-11-04", "2024-11-24", "2024-12-14", "2025-01-03", "2025-01-06", "2025-01-26",
    "2025-02-15", "2025-03-07", "2025-03-27", "2025-04-16", "2025-05-06", "2025-05-26",
    "2025-06-15", "2025-07-05", "2025-07-06", "2025-07-26", "2025-08-15", "2025-09-04",
    "2025-09-24"
]

# --- 1. 数据读取与准备 (保持不变，直至 try/except 结束) ---
for DATE_COL in DATE_COLS:
    print(f"\n=== 正在处理日期: {DATE_COL} ===")

    try:
        # 1.1 读取后验均值 (mu)
        sheet_name_mu = f"{DATE_COL}_Results"
        df_mu = pd.read_excel(BL_RESULTS_FILE_PATH, sheet_name=sheet_name_mu,
                              index_col=0, header=0, usecols="A,B")
        df_mu.columns = ['后验收益_MuBar']

        # 获取股票列表和均值向量
        asset_list = df_mu.index.astype(str).tolist()
        mu = df_mu['后验收益_MuBar'].values
        N = len(mu)
        print(f"成功读取均值数据，Sheet: {sheet_name_mu}，资产数量 N: {N}")

        # 1.2 读取后验协方差矩阵 (Sigma)
        sheet_name_cov = DATE_COL
        df_Sigma = pd.read_excel(BL_RESULTS_FILE_PATH,
                                 sheet_name=sheet_name_cov, index_col=0)
        print(f"成功读取协方差矩阵，Sheet: {sheet_name_cov}")

        # 1.3 确保协方差矩阵与均值向量的资产列表对齐
        df_Sigma_aligned = df_Sigma.reindex(index=asset_list, columns=asset_list)
        Sigma = df_Sigma_aligned.values

        # 1.4 对协方差矩阵进行PSD处理（保持不变）
        eigvals, eigvecs = np.linalg.eigh(Sigma)
        eigvals = np.maximum(eigvals, 1e-8)
        Sigma = eigvecs @ np.diag(eigvals) @ eigvecs.T
        Sigma = cp.psd_wrap(Sigma)

        if Sigma.shape != (N, N):
            raise ValueError(f"协方差矩阵维度 {Sigma.shape} 与均值向量 N={N} 不匹配。")

    #     # 1.5 读取基准权重 (w0) 和市值 (market_cap)
    #
    #     # 读取基准权重 (w0)
    #     df_w0 = pd.read_excel(BL_RESULTS_FILE_PATH, sheet_name="基准权重",
    #                           index_col='股票代码')
    #     w0_series = df_w0.reindex(asset_list)[DATE_COL]
    #     w0_series = w0_series.fillna(0)
    #     w0 = w0_series.values
    #     if len(w0) != N:
    #         raise ValueError("基准权重 w0 的数量与均值 mu 的数量不匹配。")
    #
    #     # 读取市值 (market_cap)
    #     df_market_cap = pd.read_excel(BL_RESULTS_FILE_PATH, sheet_name="市值",
    #                                   index_col='股票代码')
    #     market_cap_series = df_market_cap.reindex(asset_list)[DATE_COL]
    #     market_cap_series = market_cap_series.fillna(0)
    #     market_cap = market_cap_series.values
    #
    #     if len(market_cap) != N:
    #         raise ValueError("市值的数量与均值 mu 的数量不匹配。")
    #
    except Exception as e:
        # **重要：在数据读取失败时，asset_list/N/w0 可能未定义或不正确，跳过当前日期**
        print(f"数据读取或对齐过程中发生错误: {e}")
        continue  # 跳过当前循环，进入下一个 DATE_COL
    #
    # StdMarketCap = zscore(market_cap)
    # print("数据读取完成，可以进行后续优化。")

    # --- 2. 优化问题求解 ---

    # 2.1 定义优化变量 w
    w = cp.Variable(N)

    # 设置显式初始点 (保持不变)
    initial_guess = generate_random_weights(N)
    w.value = initial_guess
    print(f"设置 CVXPY 变量 w 的初始点 (随机且和为 1)。")

    # # 初始化 w_before 的逻辑修复 (用于正则化项的基准)
    # if w_before is None:
    #     w_before_for_optimization = w0  # 使用 w0 作为第一个周期的 w_before
    #     print(f"首次优化：w_before (正则化基准) 初始化为基准权重 w0。")
    # else:
    #     w_before_for_optimization = w_before

    # 2.2 定义目标函数 (保持不变)
    objective = cp.Minimize(
        -w @ mu +
        lambda_value * cp.quad_form(w, Sigma)
    )

    # 2.3 定义约束条件 (保持不变)
    c_sum_to_one = cp.sum(w) == 1
    c_non_negative = w >= 0
    w_max = 0.01

    constraints = [
        c_sum_to_one,
        c_non_negative,
        w <= w_max * cp.sum(w)
    ]

    # 2.4 求解问题 (保持不变)
    solver_configs = [
        {"solver": cp.OSQP, "name": "OSQP", "settings": {"eps_abs": 1e-8, "eps_rel": 1e-8, "max_iter": 50000}},
        {"solver": cp.ECOS, "name": "ECOS", "settings": {"max_iters": 500}},
        {"solver": cp.SCS, "name": "SCS", "settings": {"max_iters": 10000, "eps": 1e-6}}
    ]

    problem = cp.Problem(objective, constraints)
    solved = False
    for config in solver_configs:
        try:
            print(f"尝试使用 {config['name']} 求解器...")
            problem.solve(solver=config["solver"], **config["settings"])

            if problem.status in ["optimal", "optimal_inaccurate"]:
                solved = True
                print(f"使用 {config['name']} 求解成功，状态: {problem.status}")
                break
            else:
                print(f"使用 {config['name']} 求解失败，状态: {problem.status}")

        except Exception as e:
            print(f"使用 {config['name']} 求解出错: {e}")
            continue

    if not solved:
        print("所有求解器都失败，使用默认OSQP设置...")
        problem.solve(solver=cp.OSQP)

    # --- 3. 结果输出和存储 (核心修改在这里) ---
    print(f"\n--- {DATE_COL} 优化结果 ---")

    if problem.status in ["optimal", "optimal_inaccurate"]:
        print(f"优化状态: {problem.status}")
        min_value = problem.value
        print(f"最小化目标函数值: {min_value:.6f}")
        optimal_weights = w.value
        TOLERANCE = 1e-8
        optimal_weights[optimal_weights < TOLERANCE] = 0
        # 归一化以确保总和为 1
        optimal_weights = optimal_weights / np.sum(optimal_weights)
        # ----------------------------------------
        print(f"检查：优化后权重之和: {np.sum(optimal_weights):.6f}")

        # **修改点 A: 存储为 Series，使用当前周期的 asset_list 作为索引**
        optimal_weights_series = pd.Series(optimal_weights, index=asset_list, name=DATE_COL)
        all_optimal_weights[DATE_COL] = optimal_weights_series

        # 更新 w_before 为当前周期的最优权重（用于下一个周期的正则化基准）
        w_before = optimal_weights.copy()

    else:
        print(f"优化失败，状态: {problem.status}")
        if problem.status == 'infeasible':
            print("提示：模型可能无可行解，请检查约束条件是否过于严格。")

        # 优化失败时，使用正则化基准（w_before_for_optimization）作为替代结果
        # **修改点 B: 优化失败时，也存储为 Series**
        # if w_before is not None:
        #     # 使用上期最优权重作为替代值
        #     substitute_weights = w_before_for_optimization
        # else:
        #     # 如果 w_before 还是 None (第一次失败)，则使用 w0
        #     substitute_weights = w0

        # substitute_series = pd.Series(substitute_weights, index=asset_list, name=DATE_COL)
        # all_optimal_weights[DATE_COL] = substitute_series

        # w_before 不更新，保持上一个成功的值

# --- 4. 输出结果到Excel (核心修改在这里) ---
if all_optimal_weights:

    # **修改点 C: 使用 from_dict 和 orient='columns' 自动对齐索引**
    weights_df = pd.DataFrame.from_dict(all_optimal_weights, orient='columns')

    print("\n成功构建权重DataFrame。")

    # 输出到Excel文件
    output_file = r"C:\Users\cufet\Desktop\优化权重结果.xlsx"
    weights_df.to_excel(output_file)
    print(f"\n所有优化权重已保存到: {output_file}")

    # 打印汇总信息
    print(f"\n=== 优化完成汇总 ===")
    print(f"处理了 {len(DATE_COLS)} 个日期")
    print(f"生成的权重矩阵形状: {weights_df.shape}")
    print(f"权重数据已保存到Excel文件")
else:
    print("没有成功的优化结果可输出")
