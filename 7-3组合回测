from datetime import timedelta
import pandas as pd
import numpy as np
import os
import warnings
import matplotlib

matplotlib.use('TkAgg')
import matplotlib.pyplot as plt

import matplotlib.dates as mdates
from datetime import timedelta

# --- è¾…åŠ©è®¾ç½® ---
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False
# å¿½ç•¥ openpyxl ç›¸å…³çš„è­¦å‘Š
warnings.filterwarnings("ignore", category=UserWarning, module="openpyxl")


# =========================================================================
# === SimplePortfolioBacktester ç±»å®šä¹‰ (å·²ä¿®æ”¹) ===
# =========================================================================

class SimplePortfolioBacktester:
    # ç­–ç•¥åç§°æ›´æ–°ä¸ºåˆå¹¶ç­–ç•¥
    STRATEGY_NAME = 'æœ€ç»ˆåˆå¹¶ç­–ç•¥'

    def __init__(self, data_path, stock_data_file, csi_data_file, csi500_simple_data_file):
        self.data_path = data_path
        self.stock_data_file = stock_data_file

        self.csi500_tr_data_file = csi_data_file
        self.csi500_sr_data_file = csi500_simple_data_file

        self.price_data = None
        self.custom_matrix = None

        self.csi500_tr_returns = None
        self.csi500_sr_returns = None

        self.metrics_results = {}
        self.daily_holdings_history = []

        self.initial_capital = 1000000000  # åˆå§‹èµ„é‡‘10äº¿
        self.buy_fee = 0.0003  # ä¹°å…¥è´¹ç‡ 0.03% (ä¸‡3)
        self.sell_fee = 0.0013  # å–å‡ºè´¹ç‡ 0.13% (å«å°èŠ±ç¨)

        self._load_all_data()

    def _load_all_data(self):
        """åŠ è½½æ‰€æœ‰æ•°æ®ï¼šè‚¡ç¥¨ä»·æ ¼ã€è‡ªå®šä¹‰ç»„åˆçŸ©é˜µã€ä¸­è¯500å…¨æ”¶ç›Šã€ä¸­è¯500æ™®é€šæ”¶ç›Šã€‚"""

        # 1. åŠ è½½è‚¡ç¥¨æ”¶ç›˜ä»· (å‡è®¾è·¯å¾„)
        try:
            file_path = os.path.join(self.data_path, self.stock_data_file)
            df = pd.read_excel(file_path, sheet_name='Sheet1', header=0)
            df = df.iloc[1:].set_index(df.columns[0])
            df.index = pd.to_datetime(df.index)
            df.columns = df.columns.astype(str)
            self.price_data = df.apply(pd.to_numeric, errors='coerce').ffill()
            print(f"è‚¡ç¥¨ä»·æ ¼æ•°æ®å½¢çŠ¶: {self.price_data.shape}")
        except Exception as e:
            print(f"åŠ è½½è‚¡ç¥¨ä»·æ ¼æ•°æ®å¤±è´¥: {e}")
            self.price_data = pd.DataFrame()

        # 2. åŠ è½½è‡ªå®šä¹‰ç»„åˆçŠ¶æ€çŸ©é˜µ (æƒé‡æ–‡ä»¶å·²ä¿®æ”¹)
        try:
            # ğŸš¨ ä¿®æ”¹ç‚¹ 1: æƒé‡æ–‡ä»¶è·¯å¾„æ›´æ–°ä¸ºåˆå¹¶åçš„æƒé‡
            weights_file_path = os.path.join(self.data_path, 'æœ€ç»ˆåˆå¹¶æƒé‡_70_30.xlsx')
            df = pd.read_excel(weights_file_path, sheet_name='Sheet1', index_col=0)  # å‡è®¾å¯¼å‡ºçš„Excelé»˜è®¤Sheetä¸ºSheet1
            self.custom_matrix = df
            self.custom_matrix.index = self.custom_matrix.index.astype(str)
            self.custom_matrix.columns = pd.to_datetime(self.custom_matrix.columns)
            print(f"è‡ªå®šä¹‰æƒé‡çŸ©é˜µå½¢çŠ¶ (æœ€ç»ˆåˆå¹¶ç­–ç•¥): {self.custom_matrix.shape}")
        except Exception as e:
            # å°è¯•ä¸æŒ‡å®š sheet_nameï¼Œç›´æ¥è¯»å–ç¬¬ä¸€ä¸ªsheet
            try:
                df = pd.read_excel(weights_file_path, index_col=0)
                self.custom_matrix = df
                self.custom_matrix.index = self.custom_matrix.index.astype(str)
                self.custom_matrix.columns = pd.to_datetime(self.custom_matrix.columns)
                print(f"è‡ªå®šä¹‰æƒé‡çŸ©é˜µå½¢çŠ¶ (æœ€ç»ˆåˆå¹¶ç­–ç•¥ - é»˜è®¤Sheet): {self.custom_matrix.shape}")
            except Exception as e_retry:
                print(f"åŠ è½½è‡ªå®šä¹‰æƒé‡çŸ©é˜µå¤±è´¥ (å·²å°è¯•é»˜è®¤Sheet)ã€‚è¯¦ç»†ä¿¡æ¯: {e_retry}")
                self.custom_matrix = pd.DataFrame()

        # 3. åŠ è½½ä¸­è¯500å…¨æ”¶ç›ŠæŒ‡æ•°æ•°æ® (CSI500_TR)
        try:
            file_path = os.path.join(self.data_path, self.csi500_tr_data_file)
            df = pd.read_excel(file_path, header=0)
            df.rename(columns={df.columns[0]: 'Date', df.columns[1]: 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.csi500_tr_returns = df['Close'].pct_change().dropna()
            print(f"ä¸­è¯500å…¨æ”¶ç›ŠæŒ‡æ•°æ•°æ®å½¢çŠ¶: {self.csi500_tr_returns.shape}")
        except Exception as e:
            print(f"åŠ è½½ä¸­è¯500å…¨æ”¶ç›ŠæŒ‡æ•°æ•°æ®å¤±è´¥: {e}")
            self.csi500_tr_returns = pd.Series()

        # 4. åŠ è½½ä¸­è¯500æ™®é€šæŒ‡æ•°æ•°æ® (CSI500_SR)
        try:
            file_path = os.path.join(self.data_path, self.csi500_sr_data_file)
            df = pd.read_excel(file_path, header=0)
            df.rename(columns={df.columns[0]: 'Date', df.columns[1]: 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.csi500_sr_returns = df['Close'].pct_change().dropna()
            print(f"ä¸­è¯500æ™®é€šæŒ‡æ•°æ•°æ®å½¢çŠ¶: {self.csi500_sr_returns.shape}")
        except Exception as e:
            print(f"åŠ è½½ä¸­è¯500æ™®é€šæŒ‡æ•°æ•°æ®å¤±è´¥: {e}")
            self.csi500_sr_returns = pd.Series()

    # (get_custom_weights_by_date æ–¹æ³•ä¿æŒä¸å˜)
    def get_custom_weights_by_date(self, rebalance_date):
        if self.custom_matrix.empty:
            return {}

        rebalance_date = pd.to_datetime(rebalance_date)

        valid_cols = self.custom_matrix.columns[self.custom_matrix.columns <= rebalance_date]
        if valid_cols.empty:
            return {}

        target_col_date = valid_cols.max()

        weights_series = self.custom_matrix[target_col_date].dropna()
        new_weights = weights_series[weights_series > 1e-8].to_dict()

        if not new_weights:
            return {}

        available_stocks_weights = {
            s: w for s, w in new_weights.items()
            if s in self.price_data.columns
        }

        total_weight = sum(available_stocks_weights.values())
        if total_weight > 0:
            available_stocks_weights = {s: w / total_weight for s, w in available_stocks_weights.items()}

        return available_stocks_weights

    def run_backtest(self, start_date='2023-01-20', end_date='2025-09-30'):
        """æ‰§è¡Œå›æµ‹å¹¶è¿”å›ç»“æœDataFrameï¼Œé‡‡ç”¨å¢é‡è°ƒä»“é€»è¾‘ï¼Œå¹¶è®¡ç®—ä¸¤ä¸ªä¸­è¯500åŸºå‡†å‡€å€¼ã€‚"""

        if (self.price_data.empty or self.custom_matrix.empty or
                self.csi500_tr_returns.empty or self.csi500_sr_returns.empty):
            print("æ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•è¿›è¡Œå›æµ‹ã€‚")
            return None

        # --- ç¡®å®šå›æµ‹å‘¨æœŸå’Œè°ƒä»“æ—¥ ---
        rebalance_dates = self.custom_matrix.columns.sort_values().tolist()
        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)

        all_trading_dates = self.price_data.index.intersection(self.csi500_tr_returns.index).intersection(
            self.csi500_sr_returns.index)
        all_trading_dates = all_trading_dates[
            (all_trading_dates >= start_dt) &
            (all_trading_dates <= end_dt)
            ]

        if all_trading_dates.empty:
            print("å›æµ‹åŒºé—´å†…æ— äº¤æ˜“æ—¥æ•°æ®ã€‚")
            return None

        first_trading_date = all_trading_dates[0]
        future_rebalance_dates = [d for d in rebalance_dates if d > first_trading_date and d <= end_dt]

        # --- åˆå§‹åŒ– ---
        # ğŸš¨ ä¿®æ”¹ç‚¹ 2: ç­–ç•¥åç§°æ›´æ–°
        strategy_name = self.STRATEGY_NAME
        current_shares = {}
        cash = self.initial_capital
        cumulative_returns = pd.Series(index=all_trading_dates, dtype=float)

        csi500_tr_value = self.initial_capital
        csi500_tr_values = pd.Series(index=all_trading_dates, dtype=float)

        csi500_sr_value = self.initial_capital
        csi500_sr_values = pd.Series(index=all_trading_dates, dtype=float)

        self.daily_holdings_history = []

        print(f"--- å›æµ‹å¼€å§‹ ({strategy_name})ï¼Œåˆå§‹èµ„é‡‘: {self.initial_capital / 10000:.0f} ä¸‡å…ƒ ---")

        # è®°å½•å‰ä¸€æ—¥çš„æŒä»“ï¼ˆç”¨ä½œä»Šæ—¥æœŸåˆï¼‰
        prev_shares = current_shares.copy()

        for i, date in enumerate(all_trading_dates):

            # --- è®°å½•æœŸåˆæŒä»“ (å‰ä¸€æ—¥çš„æœŸæœ«) ---
            initial_holdings_data = []
            if i > 0 or (i == 0 and len(current_shares) > 0):
                try:
                    open_prices = self.price_data.loc[date].to_dict()
                except KeyError:
                    open_prices = {}

                for stock, shares in prev_shares.items():
                    price = open_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0 and shares > 0:
                        initial_holdings_data.append({
                            'æ—¥æœŸ': date,
                            'è‚¡ç¥¨ä»£ç ': stock,
                            'æŒä»“ç±»å‹': 'æœŸåˆ',
                            'æŒä»“è‚¡æ•°': shares,
                            'æ”¶ç›˜ä»·': price,
                            'æŒä»“å¸‚å€¼': shares * price
                        })

            # --- ç°é‡‘åˆ©æ¯ ---
            if i > 0:
                daily_interest_rate = 0.015 / 252
                cash += cash * daily_interest_rate

            # --- æ­¥éª¤ 1ï¼šå¤„ç† i=0 çš„åˆå§‹å‡€å€¼è®°å½• ---
            if i == 0:
                cumulative_returns.loc[date] = self.initial_capital
                csi500_tr_values.loc[date] = self.initial_capital
                csi500_sr_values.loc[date] = self.initial_capital

                # è®°å½•æœŸåˆæ•°æ®
            self.daily_holdings_history.extend(initial_holdings_data)

            # --- æ­¥éª¤ 2ï¼šå¢é‡è°ƒä»“é€»è¾‘ ---
            if date in future_rebalance_dates:
                sell_fee_total = 0
                buy_fee_total = 0

                try:
                    current_prices = self.price_data.loc[date].to_dict()
                except KeyError:
                    print(f"è­¦å‘Šï¼šè°ƒä»“æ—¥ {date.strftime('%Y-%m-%d')} ä»·æ ¼æ•°æ®ç¼ºå¤±ï¼Œè·³è¿‡è°ƒä»“ã€‚")
                    prev_shares = current_shares.copy()
                    continue

                new_weights = self.get_custom_weights_by_date(date)

                # ... å¢é‡è°ƒä»“è®¡ç®—é€»è¾‘ (ä¿æŒä¸å˜) ...
                current_market_value = sum(current_shares.get(stock, 0) * current_prices.get(stock, 0)
                                           for stock in current_shares.keys())
                current_portfolio_value = current_market_value + cash
                target_market_value = current_portfolio_value if new_weights else 0
                target_shares = {}
                stock_list_all = set(current_shares.keys()) | set(new_weights.keys())
                stock_diff = {}
                for stock in stock_list_all:
                    weight = new_weights.get(stock, 0)
                    price = current_prices.get(stock, 0)
                    current_s = current_shares.get(stock, 0)
                    if price > 0:
                        target_val = target_market_value * weight
                        target_s = int((target_val / price) // 100) * 100
                        diff = target_s - current_s
                        stock_diff[stock] = diff
                        target_shares[stock] = target_s
                sell_value_total = 0
                for stock, diff in stock_diff.items():
                    if diff < 0:
                        shares_to_sell = abs(diff)
                        price = current_prices.get(stock)
                        value = shares_to_sell * price
                        fee = value * self.sell_fee
                        sell_fee_total += fee
                        sell_value_total += value
                        current_shares[stock] = target_shares[stock]
                cash += (sell_value_total - sell_fee_total)
                buy_value_pending = 0
                buy_list = {}
                for stock, diff in stock_diff.items():
                    if diff > 0:
                        shares_to_buy = diff
                        price = current_prices.get(stock)
                        cost = shares_to_buy * price
                        buy_value_pending += cost
                        buy_list[stock] = (shares_to_buy, cost)
                if buy_value_pending > 0 and buy_value_pending <= cash:
                    for stock, (shares, cost) in buy_list.items():
                        fee = cost * self.buy_fee
                        buy_fee_total += fee
                        current_shares[stock] = target_shares[stock]
                    cash -= buy_value_pending
                    cash -= buy_fee_total
                    print(
                        f"è°ƒä»“æ—¥ {date.strftime('%Y-%m-%d')} - å–å‡ºè´¹: {sell_fee_total:.2f}, ä¹°å…¥è´¹: {buy_fee_total:.2f}, è°ƒä»“è‚¡ç¥¨æ•°: {len(current_shares)}, å‰©ä½™ç°é‡‘: {cash:.2f}")
                elif buy_value_pending > cash:
                    print(
                        f"è­¦å‘Šï¼šè°ƒä»“æ—¥ {date.strftime('%Y-%m-%d')} è´­ä¹°ç°é‡‘ä¸è¶³ ({buy_value_pending:.2f} > {cash:.2f})ï¼Œæ”¾å¼ƒæœ¬æ¬¡ä¹°å…¥ã€‚")
                    for stock, diff in stock_diff.items():
                        if diff < 0:
                            pass
                # -------------------------------------------------------------

            # --- æ­¥éª¤ 3ï¼šæ¯æ—¥å‡€å€¼æ›´æ–° ---
            yesterday = all_trading_dates[i - 1] if i > 0 else date
            stock_market_value = 0

            end_holdings_data = []

            if current_shares:
                portfolio_stocks = list(current_shares.keys())
                try:
                    today_prices = self.price_data.loc[date, portfolio_stocks].to_dict()
                except KeyError:
                    if i > 0:
                        portfolio_value = cumulative_returns.loc[yesterday]
                        cumulative_returns.loc[date] = portfolio_value
                        csi500_tr_values.loc[date] = csi500_tr_values.loc[yesterday]
                        csi500_sr_values.loc[date] = csi500_sr_values.loc[yesterday]

                        prev_shares = current_shares.copy()
                        continue
                    else:
                        portfolio_value = self.initial_capital

                for stock, shares in current_shares.items():
                    price = today_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0:
                        stock_market_value += shares * price

                        end_holdings_data.append({
                            'æ—¥æœŸ': date,
                            'è‚¡ç¥¨ä»£ç ': stock,
                            'æŒä»“ç±»å‹': 'æœŸæœ«',
                            'æŒä»“è‚¡æ•°': shares,
                            'æ”¶ç›˜ä»·': price,
                            'æŒä»“å¸‚å€¼': shares * price
                        })

                if date in future_rebalance_dates:
                    new_weights = self.get_custom_weights_by_date(date)
                    end_holdings_data = [holding for holding in end_holdings_data
                                         if new_weights.get(holding['è‚¡ç¥¨ä»£ç '], 0) > 0]

            portfolio_value = stock_market_value + cash

            # åŸºå‡†å‡€å€¼æ›´æ–°
            daily_csi500_tr_return = self.csi500_tr_returns.get(date, 0.0)
            daily_csi500_sr_return = self.csi500_sr_returns.get(date, 0.0)

            if i > 0:
                csi500_tr_value *= (1 + daily_csi500_tr_return)
                csi500_sr_value *= (1 + daily_csi500_sr_return)

                # --- æ­¥éª¤ 4ï¼šè®°å½•å‡€å€¼ ---
            if i > 0 or (i == 0 and len(current_shares) > 0):
                cumulative_returns.loc[date] = portfolio_value
                csi500_tr_values.loc[date] = csi500_tr_value
                csi500_sr_values.loc[date] = csi500_sr_value

            self.daily_holdings_history.extend(end_holdings_data)
            prev_shares = current_shares.copy()

        # å°†å‡€å€¼æ•°æ®åˆå¹¶ï¼Œå¹¶è®¡ç®—æ¯æ—¥æ”¶ç›Šç‡
        cumulative_value_df = pd.DataFrame({
            strategy_name: cumulative_returns,
            'CSI500_TR_Benchmark_Value': csi500_tr_values,
            'CSI500_SR_Benchmark_Value': csi500_sr_values
        }).dropna()

        daily_returns_df = cumulative_value_df.pct_change().dropna()
        self.calculate_metrics(daily_returns_df, cumulative_value_df)

        # å­£åº¦æ”¶ç›Šç‡ç»Ÿè®¡
        quarterly_value_df = cumulative_value_df.resample('Q').ffill().dropna()
        quarterly_returns_df = quarterly_value_df.pct_change().dropna()

        quarterly_returns_df.rename(columns={
            strategy_name: f'{strategy_name}_å­£åº¦æ”¶ç›Šç‡(%)',
            'CSI500_TR_Benchmark_Value': 'CSI500_TR_Benchmark_å­£åº¦æ”¶ç›Šç‡(%)',
            'CSI500_SR_Benchmark_Value': 'CSI500_SR_Benchmark_å­£åº¦æ”¶ç›Šç‡(%)'
        }, inplace=True)

        quarterly_returns_df *= 100
        print("\n--- å­£åº¦æ”¶ç›Šç‡ç»Ÿè®¡ ---")
        print(quarterly_returns_df)

        # æœ€ç»ˆè¿”å›ç´¯è®¡æ”¶ç›Šç‡ç™¾åˆ†æ¯”
        results_df = pd.DataFrame({
            strategy_name: (cumulative_returns / self.initial_capital - 1) * 100,
            'CSI500_TR_Benchmark': (csi500_tr_values / self.initial_capital - 1) * 100,
            'CSI500_SR_Benchmark': (csi500_sr_values / self.initial_capital - 1) * 100
        })

        return results_df.dropna()

    def _output_holdings_to_excel(self, output_file_name):
        """å°†æ”¶é›†åˆ°çš„æ¯æ—¥æŒä»“å¸‚å€¼æ•°æ®å¯¼å‡ºåˆ° Excelï¼ŒæŒ‰è°ƒä»“æ—¥åˆ†sheetï¼Œå®½æ•°æ®æ ¼å¼"""
        if not self.daily_holdings_history:
            print("æŒä»“å†å²æ•°æ®ä¸ºç©ºï¼Œä¸è¿›è¡Œå¯¼å‡ºã€‚")
            return

        df = pd.DataFrame(self.daily_holdings_history)
        df['æ—¥æœŸ'] = pd.to_datetime(df['æ—¥æœŸ'])
        df = df[df['æŒä»“ç±»å‹'] == 'æœŸæœ«']

        rebalance_dates = self.custom_matrix.columns.sort_values().tolist()
        df_start_date = df['æ—¥æœŸ'].min()

        output_path = os.path.join(self.data_path, output_file_name)  # ä½¿ç”¨ä¼ å…¥çš„ output_file_name

        try:
            # ä½¿ç”¨ ExcelWriter å†™å…¥ç»“æœ
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                # ä¸ºæ¯ä¸ªè°ƒä»“å‘¨æœŸåˆ›å»ºä¸€ä¸ªsheet
                for i in range(len(rebalance_dates)):
                    if i == 0:
                        start_date = df_start_date
                        end_date = rebalance_dates[i]
                        if end_date < start_date:
                            end_date = start_date
                        period_df = df[(df['æ—¥æœŸ'] >= start_date) & (df['æ—¥æœŸ'] <= end_date)]
                        sheet_name = f"å‘¨æœŸ1_{end_date.strftime('%Y%m%d')}"

                    else:
                        start_date = rebalance_dates[i - 1] + timedelta(days=1)
                        end_date = rebalance_dates[i]
                        period_df = df[(df['æ—¥æœŸ'] >= start_date) & (df['æ—¥æœŸ'] <= end_date)]
                        sheet_name = f"å‘¨æœŸ{i + 1}_{end_date.strftime('%Y%m%d')}"

                    if period_df.empty:
                        print(f"è·³è¿‡ç©ºsheet: {sheet_name} (æ— æ•°æ®)")
                        continue

                    pivot_df = period_df.pivot_table(
                        index='è‚¡ç¥¨ä»£ç ',
                        columns='æ—¥æœŸ',
                        values='æŒä»“å¸‚å€¼',
                        aggfunc='first'
                    ).fillna(0)

                    pivot_df.to_excel(writer, sheet_name=sheet_name)
                    print(f"åˆ›å»ºsheet: {sheet_name}, æ•°æ®å½¢çŠ¶: {pivot_df.shape}")

                # æœ€åä¸€ä¸ªè°ƒä»“å‘¨æœŸä¹‹åçš„æ•°æ®
                if rebalance_dates:
                    last_rebalance = rebalance_dates[-1]
                    last_period_df = df[df['æ—¥æœŸ'] > last_rebalance]
                    if not last_period_df.empty:
                        sheet_name = f"æœ€åå‘¨æœŸ_{df['æ—¥æœŸ'].max().strftime('%Y%m%d')}"
                        pivot_df = last_period_df.pivot_table(
                            index='è‚¡ç¥¨ä»£ç ',
                            columns='æ—¥æœŸ',
                            values='æŒä»“å¸‚å€¼',
                            aggfunc='first'
                        ).fillna(0)
                        pivot_df.to_excel(writer, sheet_name=sheet_name)
                        print(f"åˆ›å»ºsheet: {sheet_name}, æ•°æ®å½¢çŠ¶: {pivot_df.shape}")

            print(f"\næˆåŠŸå¯¼å‡ºä¸ªè‚¡æŒä»“å¸‚å€¼è¯¦æƒ…è‡³: {output_path}")

        except Exception as e:
            print(f"\nå¯¼å‡ºä¸ªè‚¡æŒä»“å¸‚å€¼è¯¦æƒ…å¤±è´¥: {e}")

    def calculate_metrics(self, daily_returns_df, cumulative_value_df):
        """è®¡ç®—é›·è¾¾å›¾æ‰€éœ€æŒ‡æ ‡ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨ self.metrics_results ä¸­ã€‚"""
        if daily_returns_df.empty or cumulative_value_df.empty:
            print("æ¯æ—¥æ”¶ç›Šç‡æˆ–ç´¯è®¡å‡€å€¼æ•°æ®ä¸ºç©ºï¼Œæ— æ³•è®¡ç®—ç»©æ•ˆæŒ‡æ ‡ã€‚")
            return

        risk_free_rate_daily = 0.015 / 250
        trading_days_per_year = 250

        strategy_col = self.STRATEGY_NAME
        csi_col_daily = 'CSI500_TR_Benchmark_Value'  # ç”¨äºç›¸å¯¹æŒ‡æ ‡ (å…¨æ”¶ç›Šä¸ºåŸºå‡†)

        total_days = len(daily_returns_df)
        total_return_strategy = (1 + daily_returns_df[strategy_col]).prod() - 1

        annualized_return_strategy = (1 + total_return_strategy) ** (trading_days_per_year / total_days) - 1
        annualized_volatility_strategy = daily_returns_df[strategy_col].std() * np.sqrt(trading_days_per_year)

        cumulative_wealth = cumulative_value_df[strategy_col] / self.initial_capital
        peak = cumulative_wealth.expanding(min_periods=1).max()
        drawdown = (cumulative_wealth / peak) - 1
        max_drawdown = drawdown.min()

        min_wealth = cumulative_wealth.expanding(min_periods=1).min()
        max_gain_series = cumulative_wealth / min_wealth - 1
        max_gain_period = max_gain_series.max()

        sharpe_ratio = (annualized_return_strategy - (
                risk_free_rate_daily * trading_days_per_year)) / annualized_volatility_strategy if annualized_volatility_strategy else np.nan

        calmar_ratio = annualized_return_strategy / abs(max_drawdown) if abs(max_drawdown) > 0 else np.nan

        tracking_difference = daily_returns_df[strategy_col] - daily_returns_df[csi_col_daily]
        tracking_error = tracking_difference.std() * np.sqrt(trading_days_per_year)

        csi_annual_return = (1 + daily_returns_df[csi_col_daily].prod()) ** (trading_days_per_year / total_days) - 1
        annual_excess_vs_csi = annualized_return_strategy - csi_annual_return
        information_ratio = annual_excess_vs_csi / tracking_error if tracking_error != 0 else np.nan

        win_days = (daily_returns_df[strategy_col] > daily_returns_df[csi_col_daily]).sum()
        relative_win_rate = win_days / total_days

        self.metrics_results = {
            'å¹´åŒ–æ”¶ç›Šç‡': annualized_return_strategy,
            'å¹´åŒ–æ³¢åŠ¨ç‡': annualized_volatility_strategy,
            'åŒºé—´æœ€å¤§æ¶¨å¹…': max_gain_period,
            'åŒºé—´æœ€å¤§å›æ’¤': abs(max_drawdown),
            'å¤æ™®æ¯”ç‡': sharpe_ratio,
            'Calmaræ¯”ç‡': calmar_ratio,
            'ä¿¡æ¯æ¯”ç‡': information_ratio,
            'ç›¸å¯¹åŸºå‡†èƒœç‡': relative_win_rate
        }

        print("\n" + "=" * 50)
        print(f"======== ç­–ç•¥ç»©æ•ˆæŒ‡æ ‡ ({self.STRATEGY_NAME}) ========")
        print("=" * 50)
        for name, value in self.metrics_results.items():
            if name in ['å¹´åŒ–æ”¶ç›Šç‡', 'å¹´åŒ–æ³¢åŠ¨ç‡', 'åŒºé—´æœ€å¤§æ¶¨å¹…', 'åŒºé—´æœ€å¤§å›æ’¤', 'ç›¸å¯¹åŸºå‡†èƒœç‡']:
                print(f"{name}: {value * 100:.2f}%")
            else:
                print(f"{name}: {value:.2f}")
        print("=" * 50)


def plot_performance(results_df, initial_capital=1000000000, strategy_name='æœ€ç»ˆåˆå¹¶ç­–ç•¥'):
    """
    ç»˜åˆ¶æŠ•èµ„ç»„åˆç´¯ç§¯æ”¶ç›Šç‡å›¾è¡¨ï¼Œé€‚é…BLä¼˜åŒ–ç­–ç•¥å’Œä¸¤ä¸ªCSI500åŸºå‡†ã€‚

    Args:
        results_df (pd.DataFrame): åŒ…å«ç­–ç•¥å’ŒåŸºå‡†ç´¯è®¡æ”¶ç›Šç‡ï¼ˆ%ï¼‰çš„DataFrameã€‚
        initial_capital (int): åˆå§‹èµ„é‡‘ï¼Œç”¨äºå›¾è¡¨æ ‡é¢˜æ˜¾ç¤ºã€‚
        strategy_name (str): ç­–ç•¥åç§°ï¼Œç”¨äºå›¾ä¾‹å’Œæ ‡é¢˜ã€‚
    """
    if results_df is None or results_df.empty:
        print("æ²¡æœ‰å¯ç”¨äºç»˜åˆ¶çš„æŠ•èµ„ç»„åˆå›æµ‹ç»“æœã€‚")
        return

    plt.rcParams['font.sans-serif'] = ['SimHei']  # è®¾ç½®ä¸­æ–‡æ˜¾ç¤º
    plt.rcParams['axes.unicode_minus'] = False  # è§£å†³è´Ÿå·'-'æ˜¾ç¤ºä¸ºæ–¹å—çš„é—®é¢˜

    plt.figure(figsize=(12, 7))

    # ç­–ç•¥é¢œè‰²å’Œæ ‡ç­¾æ˜ å°„
    strategy_config = {
        strategy_name: {'color': 'blue', 'label': strategy_name, 'linestyle': '-', 'linewidth': 2},
        'CSI500_TR_Benchmark': {'color': 'black', 'label': 'ä¸­è¯500å…¨æ”¶ç›ŠæŒ‡æ•° (TR)', 'linestyle': '--',
                                'linewidth': 2,
                                'alpha': 0.8},
    }

    # 1. ç»˜å›¾å¾ªç¯
    plotted_strategies = []
    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            data = results_df[strategy]
            plt.plot(data.index, data.values,
                     color=config['color'],
                     label=config['label'],
                     linestyle=config['linestyle'],
                     linewidth=config['linewidth'],
                     alpha=config.get('alpha', 1))
            plotted_strategies.append((strategy, config['label']))

    # 2. è®¾ç½®å›¾è¡¨æ ·å¼
    title_capital = f"åˆå§‹èµ„é‡‘ {initial_capital / 10000:.0f} ä¸‡å…ƒ"
    # ğŸš¨ ä¿®æ”¹ç‚¹ 4: æ›´æ–°å›¾è¡¨æ ‡é¢˜
    plt.title(f'{strategy_name} vs. åŸºå‡†æŒ‡æ•° ({title_capital})', fontsize=14, fontweight='bold', pad=15)

    plt.xlabel('æ—¥æœŸ', fontsize=10)
    plt.ylabel('ç´¯ç§¯æ”¶ç›Šç‡ (%)', fontsize=10)
    plt.legend(fontsize=10, loc='best')
    plt.grid(True, linestyle='--', alpha=0.6)

    # æ—¥æœŸæ ¼å¼åŒ–
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
    plt.gcf().autofmt_xdate()

    # ç»˜åˆ¶é›¶çº¿
    plt.axhline(y=0, color='red', linestyle='-', alpha=0.5, linewidth=1)
    plt.tight_layout()
    plt.show()

    # 3. æ‰“å°æœ€ç»ˆæ”¶ç›Šç‡
    print("\nå„ç­–ç•¥æœ€ç»ˆç´¯ç§¯æ”¶ç›Šç‡ç»Ÿè®¡ï¼š")
    for strategy_col, label in plotted_strategies:
        final_return = results_df[strategy_col].iloc[-1]
        print(f"{label}: {final_return:.2f}%")


# =========================================================================
# === è°ƒç”¨å‡½æ•°å’Œæ‰§è¡Œå›æµ‹çš„ç¤ºä¾‹ä»£ç  ===
# =========================================================================

if __name__ == '__main__':
    # --- 1. å®šä¹‰æ–‡ä»¶è·¯å¾„ (è¯·æ ¹æ®æ‚¨çš„å®é™…æ–‡ä»¶è·¯å¾„ä¿®æ”¹) ---
    BASE_DATA_PATH = r"C:\Users\cufet\Desktop\æµ‹è¯•é›†"

    STOCK_PRICE_FILE = r"ä¸­è¯500æˆåˆ†è‚¡æ•°æ®-å¿«ç…§2.xlsx"
    CSI500_TOTAL_RETURN_FILE = r"C:\Users\cufet\Desktop\æµ‹è¯•é›†\CSI500_TotalReturn.xls"  # ä¸­è¯500å…¨æ”¶ç›ŠæŒ‡æ•°æ•°æ®æ–‡ä»¶å
    CSI500_SIMPLE_RETURN_FILE = r"C:\Users\cufet\Desktop\æµ‹è¯•é›†\CSI500_SimpleReturn.xls"  # ä¸­è¯500æ™®é€šæ”¶ç›ŠæŒ‡æ•°æ•°æ®æ–‡ä»¶å

    # ğŸš¨ å®šä¹‰æ–°çš„è¾“å‡ºæ–‡ä»¶å
    OUTPUT_HOLDINGS_FILE = "æœ€ç»ˆåˆå¹¶ç­–ç•¥_æŒä»“å¸‚å€¼è¯¦æƒ….xlsx"

    # --- 2. å®ä¾‹åŒ–å›æµ‹å™¨ ---
    try:
        backtester = SimplePortfolioBacktester(
            data_path=BASE_DATA_PATH,
            stock_data_file=STOCK_PRICE_FILE,
            csi_data_file=CSI500_TOTAL_RETURN_FILE,
            csi500_simple_data_file=CSI500_SIMPLE_RETURN_FILE
        )

    except Exception as e:
        print(f"\n[è‡´å‘½é”™è¯¯] å®ä¾‹åŒ–å›æµ‹å™¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„å’ŒåŠ è½½é€»è¾‘: {e}")
        exit()

    # --- 3. æ‰§è¡Œå›æµ‹ ---
    print("\n" + "#" * 60)
    print("############ æ­£åœ¨æ‰§è¡Œå›æµ‹: æœ€ç»ˆåˆå¹¶ç­–ç•¥ ############")
    print("#" * 60)

    # è®¾ç½®å›æµ‹åŒºé—´
    results_df = backtester.run_backtest(
        start_date='2023-01-20',
        end_date='2025-09-30'
    )

    # --- 4. ç»“æœå¤„ç† ---
    if results_df is not None and not results_df.empty:
        print("\n--- æœ€ç»ˆå›æµ‹ç´¯è®¡æ”¶ç›Šç‡ (%) ---")
        print(results_df.tail(1))

        # --- 5. å¯¼å‡ºæŒä»“è¯¦æƒ… (ğŸš¨ ä½¿ç”¨æ–°çš„è¾“å‡ºæ–‡ä»¶å) ---
        backtester._output_holdings_to_excel(
            output_file_name=OUTPUT_HOLDINGS_FILE
        )

    else:
        print("\nå›æµ‹æ‰§è¡Œå¤±è´¥æˆ–ç»“æœä¸ºç©ºã€‚")

    if results_df is not None and not results_df.empty:
        # ğŸš¨ ä¼ å…¥ç­–ç•¥åç§°è¿›è¡Œç»˜å›¾
        plot_performance(
            results_df,
            initial_capital=backtester.initial_capital,
            strategy_name=backtester.STRATEGY_NAME
        )

    print("\nå›æµ‹ç¨‹åºè¿è¡Œç»“æŸã€‚")
